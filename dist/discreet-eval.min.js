var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/@nyariv/sandboxjs/dist/Sandbox.min.js
var SandboxGlobal = function(e) {
  if (e === globalThis) return globalThis;
  for (const t in e) this[t] = e[t];
};
var ExecContext = class {
  constructor(e, t, n, r, s, i, o, a, c, p, l, d) {
    this.ctx = e, this.constants = t, this.tree = n, this.getSubscriptions = r, this.setSubscriptions = s, this.changeSubscriptions = i, this.setSubscriptionsGlobal = o, this.changeSubscriptionsGlobal = a, this.evals = c, this.registerSandboxFunction = p, this.allowJit = l, this.evalContext = d;
  }
};
function createContext(e, t) {
  const n = new SandboxGlobal(t.globals), r = { sandbox: e, globalsWhitelist: new Set(Object.values(t.globals)), prototypeWhitelist: new Map([...t.prototypeWhitelist].map((e2) => [e2[0].prototype, e2[1]])), options: t, globalScope: new Scope(null, t.globals, n), sandboxGlobal: n };
  return r.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()), /* @__PURE__ */ new Set()), r;
}
function createExecContext(sandbox, executionTree, evalContext) {
  const evals = /* @__PURE__ */ new Map(), execContext = new ExecContext(sandbox.context, executionTree.constants, executionTree.tree, /* @__PURE__ */ new Set(), /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap(), sandbox.setSubscriptions, sandbox.changeSubscriptions, evals, (e) => sandbox.sandboxFunctions.set(e, execContext), !!evalContext, evalContext);
  if (evalContext) {
    const func = evalContext.sandboxFunction(execContext);
    evals.set(Function, func), evals.set(eval, evalContext.sandboxedEval(func)), evals.set(setTimeout, evalContext.sandboxedSetTimeout(func)), evals.set(setInterval, evalContext.sandboxedSetInterval(func));
  }
  return execContext;
}
var CodeString = class _CodeString {
  constructor(e) {
    this.ref = { str: "" }, e instanceof _CodeString ? (this.ref = e.ref, this.start = e.start, this.end = e.end) : (this.ref.str = e, this.start = 0, this.end = e.length);
  }
  substring(e, t) {
    if (!this.length) return this;
    (e = this.start + e) < 0 && (e = 0), e > this.end && (e = this.end), (t = void 0 === t ? this.end : this.start + t) < 0 && (t = 0), t > this.end && (t = this.end);
    const n = new _CodeString(this);
    return n.start = e, n.end = t, n;
  }
  get length() {
    const e = this.end - this.start;
    return e < 0 ? 0 : e;
  }
  char(e) {
    if (this.start !== this.end) return this.ref.str[this.start + e];
  }
  toString() {
    return this.ref.str.substring(this.start, this.end);
  }
  trimStart() {
    const e = /^\s+/.exec(this.toString()), t = new _CodeString(this);
    return e && (t.start += e[0].length), t;
  }
  slice(e, t) {
    return e < 0 && (e = this.end - this.start + e), e < 0 && (e = 0), void 0 === t && (t = this.end - this.start), t < 0 && (t = this.end - this.start + t), t < 0 && (t = 0), this.substring(e, t);
  }
  trim() {
    const e = this.trimStart(), t = /\s+$/.exec(e.toString());
    return t && (e.end -= t[0].length), e;
  }
  valueOf() {
    return this.toString();
  }
};
function keysOnly(e) {
  const t = Object.assign({}, e);
  for (const e2 in t) t[e2] = true;
  return t;
}
var reservedWords = /* @__PURE__ */ new Set(["instanceof", "typeof", "return", "throw", "try", "catch", "if", "finally", "else", "in", "of", "var", "let", "const", "for", "delete", "false", "true", "while", "do", "break", "continue", "new", "function", "async", "await", "switch", "case"]);
var Scope = class {
  constructor(e, t = {}, n) {
    this.const = {}, this.let = {}, this.var = {};
    const r = void 0 !== n || null === e;
    this.parent = e, this.allVars = t, this.let = r ? this.let : keysOnly(t), this.var = r ? keysOnly(t) : this.var, this.globals = null === e ? keysOnly(t) : {}, this.functionThis = n;
  }
  get(e, t = false) {
    const n = this.functionThis;
    if ("this" === e && void 0 !== n) return new Prop({ this: n }, e, true, false, true);
    if (reservedWords.has(e)) throw new SyntaxError("Unexepected token '" + e + "'");
    if (null === this.parent || !t || void 0 !== n) {
      if (this.globals.hasOwnProperty(e)) return new Prop(n, e, false, true, true);
      if (e in this.allVars && (!(e in {}) || this.allVars.hasOwnProperty(e))) return new Prop(this.allVars, e, this.const.hasOwnProperty(e), this.globals.hasOwnProperty(e), true);
      if (null === this.parent) return new Prop(void 0, e);
    }
    return this.parent.get(e, t);
  }
  set(e, t) {
    if ("this" === e) throw new SyntaxError('"this" cannot be assigned');
    if (reservedWords.has(e)) throw new SyntaxError("Unexepected token '" + e + "'");
    const n = this.get(e);
    if (void 0 === n.context) throw new ReferenceError(`Variable '${e}' was not declared.`);
    if (n.isConst) throw new TypeError(`Cannot assign to const variable '${e}'`);
    if (n.isGlobal) throw new SandboxError(`Cannot override global variable '${e}'`);
    if (!(n.context instanceof Object)) throw new SandboxError("Scope is not an object");
    return n.context[n.prop] = t, n;
  }
  declare(e, t, n = void 0, r = false) {
    if ("this" === e) throw new SyntaxError('"this" cannot be declared');
    if (reservedWords.has(e)) throw new SyntaxError("Unexepected token '" + e + "'");
    if ("var" === t && void 0 === this.functionThis && null !== this.parent) return this.parent.declare(e, t, n, r);
    if ((!this[t].hasOwnProperty(e) || "const" === t || this.globals.hasOwnProperty(e)) && e in this.allVars) throw new SandboxError(`Identifier '${e}' has already been declared`);
    return r && (this.globals[e] = true), this[t][e] = true, this.allVars[e] = n, new Prop(this.allVars, e, this.const.hasOwnProperty(e), r);
  }
};
var LocalScope = class {
};
var SandboxError = class extends Error {
};
function isLisp(e) {
  return Array.isArray(e) && "number" == typeof e[0] && 0 !== e[0] && 88 !== e[0];
}
var Prop = class {
  constructor(e, t, n = false, r = false, s = false) {
    this.context = e, this.prop = t, this.isConst = n, this.isGlobal = r, this.isVariable = s;
  }
  get(e) {
    const t = this.context;
    if (void 0 === t) throw new ReferenceError(`${this.prop} is not defined`);
    if (null === t) throw new TypeError(`Cannot read properties of null, (reading '${this.prop}')`);
    return e.getSubscriptions.forEach((e2) => e2(t, this.prop)), t[this.prop];
  }
};
var ExecReturn = class {
  constructor(e, t, n, r = false, s = false) {
    this.auditReport = e, this.result = t, this.returned = n, this.breakLoop = r, this.continueLoop = s;
  }
};
var optional = {};
function generateArgs(e, t) {
  const n = {};
  return e.forEach((e2, r) => {
    e2.startsWith("...") ? n[e2.substring(3)] = t.slice(r) : n[e2] = t[r];
  }), n;
}
var sandboxedFunctions = /* @__PURE__ */ new WeakSet();
function createFunction(e, t, n, r, s, i) {
  if (r.ctx.options.forbidFunctionCreation) throw new SandboxError("Function creation is forbidden");
  let o;
  return o = void 0 === i ? (...i2) => {
    const o2 = generateArgs(e, i2);
    return executeTree(n, r, t, void 0 === s ? [] : [new Scope(s, o2)]).result;
  } : function(...i2) {
    const o2 = generateArgs(e, i2);
    return executeTree(n, r, t, void 0 === s ? [] : [new Scope(s, o2, this)]).result;
  }, r.registerSandboxFunction(o), sandboxedFunctions.add(o), o;
}
function createFunctionAsync(e, t, n, r, s, i) {
  if (r.ctx.options.forbidFunctionCreation) throw new SandboxError("Function creation is forbidden");
  if (!r.ctx.prototypeWhitelist?.has(Promise.prototype)) throw new SandboxError("Async/await not permitted");
  let o;
  return o = void 0 === i ? async (...i2) => {
    const o2 = generateArgs(e, i2);
    return (await executeTreeAsync(n, r, t, void 0 === s ? [] : [new Scope(s, o2)])).result;
  } : async function(...i2) {
    const o2 = generateArgs(e, i2);
    return (await executeTreeAsync(n, r, t, void 0 === s ? [] : [new Scope(s, o2, this)])).result;
  }, r.registerSandboxFunction(o), sandboxedFunctions.add(o), o;
}
function assignCheck(e, t, n = "assign") {
  if (void 0 === e.context) throw new ReferenceError(`Cannot ${n} value to undefined.`);
  if ("object" != typeof e.context && "function" != typeof e.context) throw new SyntaxError(`Cannot ${n} value to a primitive.`);
  if (e.isConst) throw new TypeError(`Cannot set value to const variable '${e.prop}'`);
  if (e.isGlobal) throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);
  if (null === e.context) throw new TypeError("Cannot set properties of null");
  if ("function" == typeof e.context[e.prop] && !e.context.hasOwnProperty(e.prop)) throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);
  "delete" === n ? e.context.hasOwnProperty(e.prop) && (t.changeSubscriptions.get(e.context)?.forEach((t2) => t2({ type: "delete", prop: e.prop })), t.changeSubscriptionsGlobal.get(e.context)?.forEach((t2) => t2({ type: "delete", prop: e.prop }))) : e.context.hasOwnProperty(e.prop) ? (t.setSubscriptions.get(e.context)?.get(e.prop)?.forEach((e2) => e2({ type: "replace" })), t.setSubscriptionsGlobal.get(e.context)?.get(e.prop)?.forEach((e2) => e2({ type: "replace" }))) : (t.changeSubscriptions.get(e.context)?.forEach((t2) => t2({ type: "create", prop: e.prop })), t.changeSubscriptionsGlobal.get(e.context)?.forEach((t2) => t2({ type: "create", prop: e.prop })));
}
var arrayChange = /* @__PURE__ */ new Set([[].push, [].pop, [].shift, [].unshift, [].splice, [].reverse, [].sort, [].copyWithin]);
var KeyVal = class {
  constructor(e, t) {
    this.key = e, this.val = t;
  }
};
var SpreadObject = class {
  constructor(e) {
    this.item = e;
  }
};
var SpreadArray = class {
  constructor(e) {
    this.item = e;
  }
};
var If = class {
  constructor(e, t) {
    this.t = e, this.f = t;
  }
};
var literalRegex = /(\$\$)*(\$)?\${(\d+)}/g;
var ops = /* @__PURE__ */ new Map();
function addOps(e, t) {
  ops.set(e, t);
}
function valueOrProp(e, t) {
  return e instanceof Prop ? e.get(t) : e !== optional ? e : void 0;
}
function execMany(e, t, n, r, s, i, o) {
  t === execSync ? _execManySync(e, n, r, s, i, o) : _execManyAsync(e, n, r, s, i, o).catch(r);
}
function _execManySync(e, t, n, r, s, i) {
  const o = [];
  for (let a = 0; a < t.length; a++) {
    let c;
    try {
      c = syncDone((n2) => execSync(e, t[a], r, s, n2, i)).result;
    } catch (e2) {
      return void n(e2);
    }
    if (c instanceof ExecReturn && (c.returned || c.breakLoop || c.continueLoop)) return void n(void 0, c);
    if (isLisp(t[a]) && 8 === t[a][0]) return void n(void 0, new ExecReturn(s.ctx.auditReport, c, true));
    o.push(c);
  }
  n(void 0, o);
}
async function _execManyAsync(e, t, n, r, s, i) {
  const o = [];
  for (let a = 0; a < t.length; a++) {
    let c;
    try {
      let n2;
      c = true === (n2 = asyncDone((n3) => execAsync(e, t[a], r, s, n3, i))).isInstant ? n2.instant : (await n2.p).result;
    } catch (e2) {
      return void n(e2);
    }
    if (c instanceof ExecReturn && (c.returned || c.breakLoop || c.continueLoop)) return void n(void 0, c);
    if (isLisp(t[a]) && 8 === t[a][0]) return void n(void 0, new ExecReturn(s.ctx.auditReport, c, true));
    o.push(c);
  }
  n(void 0, o);
}
function asyncDone(e) {
  let t, n = false;
  const r = new Promise((r2, s) => {
    e((e2, i) => {
      e2 ? s(e2) : (n = true, t = i, r2({ result: i }));
    });
  });
  return { isInstant: n, instant: t, p: r };
}
function syncDone(e) {
  let t, n;
  if (e((e2, r) => {
    n = e2, t = r;
  }), n) throw n;
  return { result: t };
}
async function execAsync(e, t, n, r, s, i) {
  let o = s;
  const a = new Promise((e2) => {
    o = (t2, n2) => {
      s(t2, n2), e2();
    };
  });
  if (!_execNoneRecurse(e, t, n, r, o, true, i) && isLisp(t)) {
    let s2, a2 = t[0];
    try {
      let o2;
      s2 = true === (o2 = asyncDone((s3) => execAsync(e, t[1], n, r, s3, i))).isInstant ? o2.instant : (await o2.p).result;
    } catch (e2) {
      return void o(e2);
    }
    let c, p = s2;
    try {
      p = s2 instanceof Prop ? s2.get(r) : s2;
    } catch (e2) {
      return void o(e2);
    }
    if (20 === a2 || 21 === a2) {
      if (null == p) return void o(void 0, optional);
      a2 = 20 === a2 ? 1 : 5;
    }
    if (p === optional) {
      if (1 === a2 || 5 === a2) return void o(void 0, p);
      p = void 0;
    }
    try {
      let s3;
      c = true === (s3 = asyncDone((s4) => execAsync(e, t[2], n, r, s4, i))).isInstant ? s3.instant : (await s3.p).result;
    } catch (e2) {
      return void o(e2);
    }
    let l = c;
    try {
      l = c instanceof Prop ? c.get(r) : c;
    } catch (e2) {
      return void o(e2);
    }
    if (l === optional && (l = void 0), ops.has(a2)) try {
      ops.get(a2)?.(execAsync, o, e, p, l, s2, r, n, c, i);
    } catch (e2) {
      o(e2);
    }
    else o(new SyntaxError("Unknown operator: " + a2));
  }
  await a;
}
function execSync(e, t, n, r, s, i) {
  if (!_execNoneRecurse(e, t, n, r, s, false, i) && isLisp(t)) {
    let o, a = t[0];
    try {
      o = syncDone((s2) => execSync(e, t[1], n, r, s2, i)).result;
    } catch (e2) {
      return void s(e2);
    }
    let c, p = o;
    try {
      p = o instanceof Prop ? o.get(r) : o;
    } catch (e2) {
      return void s(e2);
    }
    if (20 === a || 21 === a) {
      if (null == p) return void s(void 0, optional);
      a = 20 === a ? 1 : 5;
    }
    if (p === optional) {
      if (1 === a || 5 === a) return void s(void 0, p);
      p = void 0;
    }
    try {
      c = syncDone((s2) => execSync(e, t[2], n, r, s2, i)).result;
    } catch (e2) {
      return void s(e2);
    }
    let l = c;
    try {
      l = c instanceof Prop ? c.get(r) : c;
    } catch (e2) {
      return void s(e2);
    }
    if (l === optional && (l = void 0), ops.has(a)) try {
      ops.get(a)?.(execSync, s, e, p, l, o, r, n, c, i);
    } catch (e2) {
      s(e2);
    }
    else s(new SyntaxError("Unknown operator: " + a));
  }
}
addOps(1, (e, t, n, r, s, i, o, a) => {
  if (null === r) throw new TypeError(`Cannot get property ${s} of null`);
  const c = typeof r;
  if ("undefined" === c && void 0 === i) {
    const e2 = a.get(s);
    if (e2.context === o.ctx.sandboxGlobal) {
      o.ctx.options.audit && o.ctx.auditReport?.globalsAccess.add(s);
      const e3 = o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[s]) ? o.evals.get(o.ctx.sandboxGlobal[s]) : void 0;
      if (e3) return void t(void 0, e3);
    }
    return e2.context && e2.context[s] === globalThis ? void t(void 0, o.ctx.globalScope.get("this")) : void t(void 0, e2);
  }
  if (void 0 === r) throw new SandboxError("Cannot get property '" + s + "' of undefined");
  if ("object" !== c) "number" === c ? r = new Number(r) : "string" === c ? r = new String(r) : "boolean" === c && (r = new Boolean(r));
  else if (void 0 === r.hasOwnProperty) return void t(void 0, new Prop(void 0, s));
  const p = "function" === c, l = p || !(r.hasOwnProperty(s) || "number" == typeof s);
  if (o.ctx.options.audit && l && "string" == typeof s) {
    let e2 = Object.getPrototypeOf(r);
    do {
      e2.hasOwnProperty(s) && (o.ctx.auditReport && !o.ctx.auditReport.prototypeAccess[e2.constructor.name] && (o.ctx.auditReport.prototypeAccess[e2.constructor.name] = /* @__PURE__ */ new Set()), o.ctx.auditReport?.prototypeAccess[e2.constructor.name].add(s));
    } while (e2 = Object.getPrototypeOf(e2));
  }
  if (l) {
    if (p) {
      if (!["name", "length", "constructor"].includes(s) && (r.hasOwnProperty(s) || "__proto__" === s)) {
        const e2 = o.ctx.prototypeWhitelist.get(r.prototype), n2 = o.ctx.options.prototypeReplacements.get(r);
        if (n2) return void t(void 0, new Prop(n2(r, true), s));
        if (!e2 || e2.size && !e2.has(s)) throw new SandboxError(`Static method or property access not permitted: ${r.name}.${s}`);
      }
    } else if ("constructor" !== s) {
      let e2 = r;
      for (; e2 = Object.getPrototypeOf(e2); ) if (e2.hasOwnProperty(s)) {
        const n2 = o.ctx.prototypeWhitelist.get(e2), i2 = o.ctx.options.prototypeReplacements.get(e2.constuctor);
        if (i2) return void t(void 0, new Prop(i2(r, false), s));
        if (n2 && (!n2.size || n2.has(s))) break;
        throw new SandboxError(`Method or property access not permitted: ${e2.constructor.name}.${s}`);
      }
    }
  }
  if (o.evals.has(r[s])) return void t(void 0, o.evals.get(r[s]));
  if (r[s] === globalThis) return void t(void 0, o.ctx.globalScope.get("this"));
  const d = i.isGlobal || p && !sandboxedFunctions.has(r) || o.ctx.globalsWhitelist.has(r);
  t(void 0, new Prop(r, s, false, d));
}), addOps(5, (e, t, n, r, s, i, o) => {
  if (o.ctx.options.forbidFunctionCalls) throw new SandboxError("Function invocations are not allowed");
  if ("function" != typeof r) throw new TypeError(`${"symbol" == typeof i.prop ? "Symbol" : i.prop} is not a function`);
  const a = s.map((e2) => e2 instanceof SpreadArray ? [...e2.item] : [e2]).flat().map((e2) => valueOrProp(e2, o));
  if ("function" != typeof i) {
    if (i.context[i.prop] === JSON.stringify && o.getSubscriptions.size) {
      const e2 = /* @__PURE__ */ new Set(), t2 = (n2) => {
        if (n2 && "object" == typeof n2 && !e2.has(n2)) {
          e2.add(n2);
          for (const e3 of Object.keys(n2)) o.getSubscriptions.forEach((t3) => t3(n2, e3)), t2(n2[e3]);
        }
      };
      t2(a[0]);
    }
    if (i.context instanceof Array && arrayChange.has(i.context[i.prop]) && (o.changeSubscriptions.get(i.context) || o.changeSubscriptionsGlobal.get(i.context))) {
      let e2, t2 = false;
      if ("push" === i.prop) e2 = { type: "push", added: a }, t2 = !!a.length;
      else if ("pop" === i.prop) e2 = { type: "pop", removed: i.context.slice(-1) }, t2 = !!e2.removed.length;
      else if ("shift" === i.prop) e2 = { type: "shift", removed: i.context.slice(0, 1) }, t2 = !!e2.removed.length;
      else if ("unshift" === i.prop) e2 = { type: "unshift", added: a }, t2 = !!a.length;
      else if ("splice" === i.prop) e2 = { type: "splice", startIndex: a[0], deleteCount: void 0 === a[1] ? i.context.length : a[1], added: a.slice(2), removed: i.context.slice(a[0], void 0 === a[1] ? void 0 : a[0] + a[1]) }, t2 = !!e2.added.length || !!e2.removed.length;
      else if ("reverse" === i.prop || "sort" === i.prop) e2 = { type: i.prop }, t2 = !!i.context.length;
      else if ("copyWithin" === i.prop) {
        const n2 = void 0 === a[2] ? i.context.length - a[1] : Math.min(i.context.length, a[2] - a[1]);
        e2 = { type: "copyWithin", startIndex: a[0], endIndex: a[0] + n2, added: i.context.slice(a[1], a[1] + n2), removed: i.context.slice(a[0], a[0] + n2) }, t2 = !!e2.added.length || !!e2.removed.length;
      }
      t2 && (o.changeSubscriptions.get(i.context)?.forEach((t3) => t3(e2)), o.changeSubscriptionsGlobal.get(i.context)?.forEach((t3) => t3(e2)));
    }
    i.get(o), t(void 0, i.context[i.prop](...a));
  } else t(void 0, i(...a));
}), addOps(22, (e, t, n, r, s) => {
  let i = {};
  for (const e2 of s) e2.key instanceof SpreadObject ? i = { ...i, ...e2.key.item } : i[e2.key] = e2.val;
  t(void 0, i);
}), addOps(6, (e, t, n, r, s) => t(void 0, new KeyVal(r, s))), addOps(12, (e, t, n, r, s, i, o) => {
  t(void 0, s.map((e2) => e2 instanceof SpreadArray ? [...e2.item] : [e2]).flat().map((e2) => valueOrProp(e2, o)));
}), addOps(23, (e, t, n, r, s) => t(void 0, s)), addOps(35, (e, t, n, r, s) => {
  switch (s) {
    case "true":
      return t(void 0, true);
    case "false":
      return t(void 0, false);
    case "null":
      return t(void 0, null);
    case "undefined":
      return t(void 0, void 0);
    case "NaN":
      return t(void 0, NaN);
    case "Infinity":
      return t(void 0, 1 / 0);
  }
  t(new Error("Unknown symbol: " + s));
}), addOps(7, (e, t, n, r, s) => t(void 0, Number(s))), addOps(83, (e, t, n, r, s) => t(void 0, BigInt(s))), addOps(2, (e, t, n, r, s, i, o) => t(void 0, o.constants.strings[parseInt(s)])), addOps(85, (e, t, n, r, s, i, o) => {
  const a = o.constants.regexes[parseInt(s)];
  if (!o.ctx.globalsWhitelist.has(RegExp)) throw new SandboxError("Regex not permitted");
  t(void 0, new RegExp(a.regex, a.flags));
}), addOps(84, (e, t, n, r, s, i, o, a) => {
  const c = o.constants.literals[parseInt(s)], [, p, l] = c, d = [];
  let u;
  const f = [];
  for (; u = literalRegex.exec(p); ) u[2] || (d.push(l[parseInt(u[3], 10)]), f.push(u[3]));
  e(n, d, a, o, (e2, n2) => {
    const r2 = {};
    if (e2) t(e2);
    else {
      for (const e3 of Object.keys(n2)) {
        const t2 = f[e3];
        r2[t2] = n2[e3];
      }
      t(void 0, p.replace(/(\\\\)*(\\)?\${(\d+)}/g, (e3, t2, n3, s2) => {
        if (n3) return e3;
        return (t2 || "") + `${valueOrProp(r2[s2], o)}`;
      }));
    }
  });
}), addOps(18, (e, t, n, r, s) => {
  t(void 0, new SpreadArray(s));
}), addOps(17, (e, t, n, r, s) => {
  t(void 0, new SpreadObject(s));
}), addOps(24, (e, t, n, r, s) => t(void 0, !s)), addOps(64, (e, t, n, r, s) => t(void 0, ~s)), addOps(25, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, ++i.context[i.prop]);
}), addOps(26, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop]++);
}), addOps(27, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, --i.context[i.prop]);
}), addOps(28, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop]--);
}), addOps(9, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] = s);
}), addOps(66, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] += s);
}), addOps(65, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] -= s);
}), addOps(67, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] /= s);
}), addOps(69, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] *= s);
}), addOps(68, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] **= s);
}), addOps(70, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] %= s);
}), addOps(71, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] ^= s);
}), addOps(72, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] &= s);
}), addOps(73, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] |= s);
}), addOps(76, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] <<= s);
}), addOps(75, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] >>= s);
}), addOps(74, (e, t, n, r, s, i, o) => {
  assignCheck(i, o), t(void 0, i.context[i.prop] >>= s);
}), addOps(57, (e, t, n, r, s) => t(void 0, r > s)), addOps(56, (e, t, n, r, s) => t(void 0, r < s)), addOps(55, (e, t, n, r, s) => t(void 0, r >= s)), addOps(54, (e, t, n, r, s) => t(void 0, r <= s)), addOps(52, (e, t, n, r, s) => t(void 0, r == s)), addOps(32, (e, t, n, r, s) => t(void 0, r === s)), addOps(53, (e, t, n, r, s) => t(void 0, r != s)), addOps(31, (e, t, n, r, s) => t(void 0, r !== s)), addOps(29, (e, t, n, r, s) => t(void 0, r && s)), addOps(30, (e, t, n, r, s) => t(void 0, r || s)), addOps(77, (e, t, n, r, s) => t(void 0, r & s)), addOps(78, (e, t, n, r, s) => t(void 0, r | s)), addOps(33, (e, t, n, r, s) => t(void 0, r + s)), addOps(47, (e, t, n, r, s) => t(void 0, r - s)), addOps(59, (e, t, n, r, s) => t(void 0, +s)), addOps(58, (e, t, n, r, s) => t(void 0, -s)), addOps(48, (e, t, n, r, s) => t(void 0, r / s)), addOps(79, (e, t, n, r, s) => t(void 0, r ^ s)), addOps(50, (e, t, n, r, s) => t(void 0, r * s)), addOps(51, (e, t, n, r, s) => t(void 0, r % s)), addOps(80, (e, t, n, r, s) => t(void 0, r << s)), addOps(81, (e, t, n, r, s) => t(void 0, r >> s)), addOps(82, (e, t, n, r, s) => t(void 0, r >>> s)), addOps(60, (e, t, n, r, s, i, o, a) => {
  e(n, s, a, o, (e2, n2) => {
    t(void 0, typeof valueOrProp(n2, o));
  });
}), addOps(62, (e, t, n, r, s) => t(void 0, r instanceof s)), addOps(63, (e, t, n, r, s) => t(void 0, r in s)), addOps(61, (e, t, n, r, s, i, o, a, c) => {
  void 0 !== c.context ? (assignCheck(c, o, "delete"), c.isVariable ? t(void 0, false) : t(void 0, delete c.context?.[c.prop])) : t(void 0, true);
}), addOps(8, (e, t, n, r, s) => t(void 0, s)), addOps(34, (e, t, n, r, s, i, o, a) => {
  t(void 0, a.declare(r, "var", s));
}), addOps(3, (e, t, n, r, s, i, o, a, c) => {
  t(void 0, a.declare(r, "let", s, c && c.isGlobal));
}), addOps(4, (e, t, n, r, s, i, o, a) => {
  t(void 0, a.declare(r, "const", s));
}), addOps(11, (e, t, n, r, s, i, o, a) => {
  if (r = [...r], "string" == typeof i[2] || i[2] instanceof CodeString) {
    if (!o.allowJit || !o.evalContext) throw new SandboxError("Unevaluated code detected, JIT not allowed");
    i[2] = s = o.evalContext.lispifyFunction(new CodeString(i[2]), o.constants);
  }
  r.shift() ? t(void 0, createFunctionAsync(r, s, n, o, a)) : t(void 0, createFunction(r, s, n, o, a));
}), addOps(37, (e, t, n, r, s, i, o, a) => {
  if ("string" == typeof i[2] || i[2] instanceof CodeString) {
    if (!o.allowJit || !o.evalContext) throw new SandboxError("Unevaluated code detected, JIT not allowed");
    i[2] = s = o.evalContext.lispifyFunction(new CodeString(i[2]), o.constants);
  }
  const c = r.shift(), p = r.shift();
  let l;
  l = 88 === c ? createFunctionAsync(r, s, n, o, a, p) : createFunction(r, s, n, o, a, p), p && a.declare(p, "var", l), t(void 0, l);
}), addOps(10, (e, t, n, r, s, i, o, a) => {
  if ("string" == typeof i[2] || i[2] instanceof CodeString) {
    if (!o.allowJit || !o.evalContext) throw new SandboxError("Unevaluated code detected, JIT not allowed");
    i[2] = s = o.evalContext.lispifyFunction(new CodeString(i[2]), o.constants);
  }
  const c = r.shift(), p = r.shift();
  let l;
  p && (a = new Scope(a, {})), l = 88 === c ? createFunctionAsync(r, s, n, o, a, p) : createFunction(r, s, n, o, a, p), p && a.declare(p, "let", l), t(void 0, l);
}), addOps(38, (e, t, n, r, s, i, o, a) => {
  const [c, p, l, d, u, f, h] = r;
  let g = true;
  const x = new Scope(a, {}), y = { $$obj: void 0 }, b = new Scope(x, y);
  if (e === execAsync) (async () => {
    let r2;
    for (r2 = asyncDone((t2) => e(n, d, x, o, t2)), y.$$obj = true === (r2 = asyncDone((t2) => e(n, l, x, o, t2))).isInstant ? r2.instant : (await r2.p).result, r2 = asyncDone((t2) => e(n, p, b, o, t2)), c && (g = true === (r2 = asyncDone((t2) => e(n, f, b, o, t2))).isInstant ? r2.instant : (await r2.p).result); g; ) {
      const i2 = {};
      r2 = asyncDone((t2) => e(n, h, new Scope(b, i2), o, t2)), true === r2.isInstant ? r2.instant : (await r2.p).result;
      const a2 = await executeTreeAsync(n, o, s, [new Scope(x, i2)], "loop");
      if (a2 instanceof ExecReturn && a2.returned) return void t(void 0, a2);
      if (a2 instanceof ExecReturn && a2.breakLoop) break;
      r2 = asyncDone((t2) => e(n, u, b, o, t2)), g = true === (r2 = asyncDone((t2) => e(n, f, b, o, t2))).isInstant ? r2.instant : (await r2.p).result;
    }
    t();
  })().catch(t);
  else {
    for (syncDone((t2) => e(n, d, x, o, t2)), y.$$obj = syncDone((t2) => e(n, l, x, o, t2)).result, syncDone((t2) => e(n, p, b, o, t2)), c && (g = syncDone((t2) => e(n, f, b, o, t2)).result); g; ) {
      const r2 = {};
      syncDone((t2) => e(n, h, new Scope(b, r2), o, t2));
      const i2 = executeTree(n, o, s, [new Scope(x, r2)], "loop");
      if (i2 instanceof ExecReturn && i2.returned) return void t(void 0, i2);
      if (i2 instanceof ExecReturn && i2.breakLoop) break;
      syncDone((t2) => e(n, u, b, o, t2)), g = syncDone((t2) => e(n, f, b, o, t2)).result;
    }
    t();
  }
}), addOps(86, (e, t, n, r, s, i, o, a, c, p) => {
  if ("switch" === p && "continue" === r || !p) throw new SandboxError("Illegal " + r + " statement");
  t(void 0, new ExecReturn(o.ctx.auditReport, void 0, false, "break" === r, "continue" === r));
}), addOps(13, (e, t, n, r, s, i, o, a) => {
  e(n, valueOrProp(r, o) ? s.t : s.f, a, o, t);
}), addOps(15, (e, t, n, r, s, i, o, a) => {
  e(n, valueOrProp(r, o) ? s.t : s.f, a, o, t);
}), addOps(16, (e, t, n, r, s) => t(void 0, new If(r, s))), addOps(14, (e, t, n, r, s) => t(void 0, new If(r, s))), addOps(40, (e, t, n, r, s, i, o, a) => {
  e(n, r, a, o, (r2, i2) => {
    if (r2) t(r2);
    else if (i2 = valueOrProp(i2, o), e === execSync) {
      let r3, c = false;
      for (const p of s) if (c || (c = !p[1] || i2 === valueOrProp(syncDone((t2) => e(n, p[1], a, o, t2)).result, o))) {
        if (!p[2]) continue;
        if (r3 = executeTree(n, o, p[2], [a], "switch"), r3.breakLoop) break;
        if (r3.returned) return void t(void 0, r3);
        if (!p[1]) break;
      }
      t();
    } else (async () => {
      let r3, c = false;
      for (const p of s) {
        let s2;
        if (c || (c = !p[1] || i2 === valueOrProp(true === (s2 = asyncDone((t2) => e(n, p[1], a, o, t2))).isInstant ? s2.instant : (await s2.p).result, o))) {
          if (!p[2]) continue;
          if (r3 = await executeTreeAsync(n, o, p[2], [a], "switch"), r3.breakLoop) break;
          if (r3.returned) return void t(void 0, r3);
          if (!p[1]) break;
        }
      }
      t();
    })().catch(t);
  });
}), addOps(39, (e, t, n, r, s, i, o, a, c, p) => {
  const [l, d, u] = s;
  executeTreeWithDone(e, (r2, s2) => {
    executeTreeWithDone(e, (i2) => {
      i2 ? t(i2) : r2 ? executeTreeWithDone(e, t, n, o, d, [new Scope(a)], p) : t(void 0, s2);
    }, n, o, u, [new Scope(a, {})]);
  }, n, o, r, [new Scope(a)], p);
}), addOps(87, (e, t) => {
  t();
}), addOps(45, (e, t, n, r, s, i, o) => {
  if (!o.ctx.globalsWhitelist.has(r) && !sandboxedFunctions.has(r)) throw new SandboxError(`Object construction not allowed: ${r.constructor.name}`);
  t(void 0, new r(...s));
}), addOps(46, (e, t, n, r, s) => {
  t(s);
}), addOps(43, (e, t, n, r) => t(void 0, r.pop())), addOps(0, (e, t) => t());
var unexecTypes = /* @__PURE__ */ new Set([11, 37, 10, 38, 39, 40, 14, 16, 60]);
var currentTicks = { current: { ticks: BigInt(0) } };
function _execNoneRecurse(e, t, n, r, s, i, o) {
  const a = i ? execAsync : execSync;
  if (r.ctx.options.executionQuota && r.ctx.options.executionQuota <= e.ticks && ("function" != typeof r.ctx.options.onExecutionQuotaReached || !r.ctx.options.onExecutionQuotaReached(e, n, r, t))) return s(new SandboxError("Execution quota exceeded")), true;
  if (e.ticks++, currentTicks.current = e, t instanceof Prop) try {
    s(void 0, t.get(r));
  } catch (e2) {
    s(e2);
  }
  else if (t === optional) s();
  else if (Array.isArray(t) && !isLisp(t)) 0 === t[0] ? s() : execMany(e, a, t, s, n, r, o);
  else if (isLisp(t)) if (42 === t[0]) execMany(e, a, t[1], s, n, r, o);
  else if (44 === t[0]) i ? r.ctx.prototypeWhitelist?.has(Promise.prototype) ? execAsync(e, t[1], n, r, async (e2, t2) => {
    if (e2) s(e2);
    else try {
      s(void 0, await valueOrProp(t2, r));
    } catch (e3) {
      s(e3);
    }
  }, o).catch(s) : s(new SandboxError("Async/await is not permitted")) : s(new SandboxError("Illegal use of 'await', must be inside async function"));
  else {
    if (!unexecTypes.has(t[0])) return false;
    try {
      ops.get(t[0])?.(a, s, e, t[1], t[2], t, r, n, void 0, o);
    } catch (e2) {
      s(e2);
    }
  }
  else s(void 0, t);
  return true;
}
function executeTree(e, t, n, r = [], s) {
  return syncDone((i) => executeTreeWithDone(execSync, i, e, t, n, r, s)).result;
}
async function executeTreeAsync(e, t, n, r = [], s) {
  let i;
  return true === (i = asyncDone((i2) => executeTreeWithDone(execAsync, i2, e, t, n, r, s))).isInstant ? i.instant : (await i.p).result;
}
function executeTreeWithDone(e, t, n, r, s, i = [], o) {
  if (!s) return void t();
  if (!(s instanceof Array)) throw new SyntaxError("Bad execution tree");
  let a, c = r.ctx.globalScope;
  for (; a = i.shift(); ) "object" == typeof a && (c = a instanceof Scope ? a : new Scope(c, a, a instanceof LocalScope ? void 0 : null));
  r.ctx.options.audit && !r.ctx.auditReport && (r.ctx.auditReport = { globalsAccess: /* @__PURE__ */ new Set(), prototypeAccess: {} }), e === execSync ? _executeWithDoneSync(t, n, r, s, c, o) : _executeWithDoneAsync(t, n, r, s, c, o).catch(t);
}
function _executeWithDoneSync(e, t, n, r, s, i) {
  if (!(r instanceof Array)) throw new SyntaxError("Bad execution tree");
  let o = 0;
  for (o = 0; o < r.length; o++) {
    let a, c;
    const p = r[o];
    try {
      execSync(t, p, s, n, (e2, t2) => {
        c = e2, a = t2;
      }, i);
    } catch (e2) {
      c = e2;
    }
    if (c) return void e(c);
    if (a instanceof ExecReturn) return void e(void 0, a);
    if (isLisp(p) && 8 === p[0]) return void e(void 0, new ExecReturn(n.ctx.auditReport, a, true));
  }
  e(void 0, new ExecReturn(n.ctx.auditReport, void 0, false));
}
async function _executeWithDoneAsync(e, t, n, r, s, i) {
  if (!(r instanceof Array)) throw new SyntaxError("Bad execution tree");
  let o = 0;
  for (o = 0; o < r.length; o++) {
    let a, c;
    const p = r[o];
    try {
      await execAsync(t, p, s, n, (e2, t2) => {
        c = e2, a = t2;
      }, i);
    } catch (e2) {
      c = e2;
    }
    if (c) return void e(c);
    if (a instanceof ExecReturn) return void e(void 0, a);
    if (isLisp(p) && 8 === p[0]) return void e(void 0, new ExecReturn(n.ctx.auditReport, a, true));
  }
  e(void 0, new ExecReturn(n.ctx.auditReport, void 0, false));
}
function parseHexToInt(e) {
  return !e.match(/[^a-f0-9]/i) ? parseInt(e, 16) : NaN;
}
function validateAndParseHex(e, t, n) {
  const r = parseHexToInt(e);
  if (Number.isNaN(r) || void 0 !== n && n !== e.length) throw new SyntaxError(t + ": " + e);
  return r;
}
function parseHexadecimalCode(e) {
  const t = validateAndParseHex(e, "Malformed Hexadecimal", 2);
  return String.fromCharCode(t);
}
function parseUnicodeCode(e, t) {
  const n = validateAndParseHex(e, "Malformed Unicode", 4);
  if (void 0 !== t) {
    const e2 = validateAndParseHex(t, "Malformed Unicode", 4);
    return String.fromCharCode(n, e2);
  }
  return String.fromCharCode(n);
}
function isCurlyBraced(e) {
  return "{" === e.charAt(0) && "}" === e.charAt(e.length - 1);
}
function parseUnicodeCodePointCode(e) {
  if (!isCurlyBraced(e)) throw new SyntaxError("Malformed Unicode: +" + e);
  const t = validateAndParseHex(e.slice(1, -1), "Malformed Unicode");
  try {
    return String.fromCodePoint(t);
  } catch (e2) {
    throw e2 instanceof RangeError ? new SyntaxError("Code Point Limit:" + t) : e2;
  }
}
var singleCharacterEscapes = /* @__PURE__ */ new Map([["b", "\b"], ["f", "\f"], ["n", "\n"], ["r", "\r"], ["t", "	"], ["v", "\v"], ["0", "\0"]]);
function parseSingleCharacterCode(e) {
  return singleCharacterEscapes.get(e) || e;
}
var escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
function unraw(e) {
  return e.replace(escapeMatch, function(e2, t, n, r, s, i, o, a, c) {
    if (void 0 !== t) return "\\";
    if (void 0 !== n) return parseHexadecimalCode(n);
    if (void 0 !== r) return parseUnicodeCodePointCode(r);
    if (void 0 !== s) return parseUnicodeCode(s, i);
    if (void 0 !== o) return parseUnicodeCode(o);
    if ("0" === a) return "\0";
    if (void 0 !== a) throw new SyntaxError("Octal Deprecation: " + a);
    if (void 0 !== c) return parseSingleCharacterCode(c);
    throw new SyntaxError("End of string");
  });
}
function createLisp(e) {
  return [e.op, e.a, e.b];
}
var NullLisp = createLisp({ op: 0, a: 0, b: 0 });
var lispTypes = /* @__PURE__ */ new Map();
var ParseError = class extends Error {
  constructor(e, t) {
    super(e + ": " + t.substring(0, 40)), this.code = t;
  }
};
var lastType;
var inlineIfElse = /^:/;
var elseIf = /^else(?![\w$])/;
var ifElse = /^if(?![\w$])/;
var space = /^\s/;
var expectTypes = { splitter: { types: { opHigh: /^(\/|\*\*|\*(?!\*)|%)(?!=)/, op: /^(\+(?!(\+))|-(?!(-)))(?!=)/, comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/, boolOp: /^(&&|\|\||instanceof(?![\w$])|in(?![\w$]))/, bitwise: /^(&(?!&)|\|(?!\|)|\^|<<|>>(?!>)|>>>)(?!=)/ }, next: ["modifier", "value", "prop", "incrementerBefore"] }, inlineIf: { types: { inlineIf: /^\?(?!\.(?!\d))/ }, next: ["expEnd"] }, assignment: { types: { assignModify: /^(-=|\+=|\/=|\*\*=|\*=|%=|\^=|&=|\|=|>>>=|>>=|<<=)/, assign: /^(=)(?!=)/ }, next: ["modifier", "value", "prop", "incrementerBefore"] }, incrementerBefore: { types: { incrementerBefore: /^(\+\+|--)/ }, next: ["prop"] }, expEdge: { types: { call: /^(\?\.)?[(]/, incrementerAfter: /^(\+\+|--)/ }, next: ["splitter", "expEdge", "dot", "inlineIf", "expEnd"] }, modifier: { types: { not: /^!/, inverse: /^~/, negative: /^-(?!-)/, positive: /^\+(?!\+)/, typeof: /^typeof(?![\w$])/, delete: /^delete(?![\w$])/ }, next: ["modifier", "value", "prop", "incrementerBefore"] }, dot: { types: { arrayProp: /^(\?\.)?\[/, dot: /^(\?)?\.(?=\s*[a-zA-Z$_])/ }, next: ["splitter", "assignment", "expEdge", "dot", "inlineIf", "expEnd"] }, prop: { types: { prop: /^[a-zA-Z$_][a-zA-Z\d$_]*/ }, next: ["splitter", "assignment", "expEdge", "dot", "inlineIf", "expEnd"] }, value: { types: { createObject: /^\{/, createArray: /^\[/, number: /^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[+-]?\d+(_\d+)*)?(n)?(?!\d)/i, string: /^"(\d+)"/, literal: /^`(\d+)`/, regex: /^\/(\d+)\/r(?![\w$])/, boolean: /^(true|false)(?![\w$])/, null: /^null(?![\w$])/, und: /^undefined(?![\w$])/, arrowFunctionSingle: /^(async\s+)?([a-zA-Z$_][a-zA-Z\d$_]*)\s*=>\s*({)?/, arrowFunction: /^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*=>\s*({)?/, inlineFunction: /^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/, group: /^\(/, NaN: /^NaN(?![\w$])/, Infinity: /^Infinity(?![\w$])/, void: /^void(?![\w$])\s*/, await: /^await(?![\w$])\s*/, new: /^new(?![\w$])\s*/ }, next: ["splitter", "expEdge", "dot", "inlineIf", "expEnd"] }, initialize: { types: { initialize: /^(var|let|const)\s+([a-zA-Z$_][a-zA-Z\d$_]*)\s*(=)?/, return: /^return(?![\w$])/, throw: /^throw(?![\w$])\s*/ }, next: ["modifier", "value", "prop", "incrementerBefore", "expEnd"] }, spreadObject: { types: { spreadObject: /^\.\.\./ }, next: ["value", "prop"] }, spreadArray: { types: { spreadArray: /^\.\.\./ }, next: ["value", "prop"] }, expEnd: { types: {}, next: [] }, expFunction: { types: { function: /^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/ }, next: ["expEdge", "expEnd"] }, expSingle: { types: { for: /^(([a-zA-Z$_][\w$]*)\s*:)?\s*for\s*\(/, do: /^(([a-zA-Z$_][\w$]*)\s*:)?\s*do(?![\w$])\s*(\{)?/, while: /^(([a-zA-Z$_][\w$]*)\s*:)?\s*while\s*\(/, loopAction: /^(break|continue)(?![\w$])\s*([a-zA-Z$_][\w$]*)?/, if: /^((([a-zA-Z$_][\w$]*)\s*:)?\s*)if\s*\(/, try: /^try\s*{/, block: /^{/, switch: /^(([a-zA-Z$_][\w$]*)\s*:)?\s*switch\s*\(/ }, next: ["expEnd"] } };
var closings = { "(": ")", "[": "]", "{": "}", "'": "'", '"': '"', "`": "`" };
function testMultiple(e, t) {
  let n = null;
  for (let r = 0; r < t.length; r++) {
    if (n = t[r].exec(e), n) break;
  }
  return n;
}
var emptyString = new CodeString("");
var okFirstChars = /^[+\-~ !]/;
var aNumber = expectTypes.value.types.number;
var wordReg = /^((if|for|else|while|do|function)(?![\w$])|[\w$]+)/;
var semiColon = /^;/;
var insertedSemicolons = /* @__PURE__ */ new WeakMap();
var quoteCache = /* @__PURE__ */ new WeakMap();
function restOfExp(e, t, n, r, s, i, o = {}) {
  if (!t.length) return t;
  o.words = o.words || [];
  let a = true;
  const c = (n = n || []).includes(semiColon);
  c && (n = n.filter((e2) => e2 !== semiColon));
  const p = insertedSemicolons.get(t.ref) || [], l = quoteCache.get(t.ref) || /* @__PURE__ */ new Map();
  if (quoteCache.set(t.ref, l), r && l.has(t.start - 1)) return t.substring(0, l.get(t.start - 1) - t.start);
  let d, u = false, f = false, h = "", g = false, x = false;
  for (d = 0; d < t.length && !f; d++) {
    let y = t.char(d);
    if ('"' === r || "'" === r || "`" === r) {
      if ("`" !== r || "$" !== y || "{" !== t.char(d + 1) || u) {
        if (y === r && !u) return t.substring(0, d);
      } else {
        d += restOfExp(e, t.substring(d + 2), [], "{").length + 2;
      }
      u = !u && "\\" === y;
    } else if (closings[y]) {
      if (!x && p[d + t.start]) {
        if (x = true, c) break;
        d--, h = ";";
        continue;
      }
      if (g && "{" === y && (g = false), y === s) {
        f = true;
        break;
      }
      {
        const n2 = restOfExp(e, t.substring(d + 1), [], y);
        if (l.set(n2.start - 1, n2.end), d += n2.length + 1, a = false, i) {
          let e2;
          (e2 = testMultiple(t.substring(d).toString(), i)) && (o.regRes = e2, f = true);
        }
      }
    } else if (r) {
      if (y === closings[r]) return t.substring(0, d);
    } else {
      let e2, r2, s2 = t.substring(d).toString();
      if (i) {
        let e3;
        if (e3 = testMultiple(s2, i)) {
          o.regRes = e3, d++, f = true;
          break;
        }
      }
      if (r2 = aNumber.exec(s2)) d += r2[0].length - 1, s2 = t.substring(d).toString();
      else if (h != y) {
        let r3 = null;
        if (";" === y || p[d + t.start] && !a && !x) {
          if (c) r3 = [";"];
          else if (p[d + t.start]) {
            x = true, d--, h = ";";
            continue;
          }
          y = s2 = ";";
        } else x = false;
        r3 || (r3 = testMultiple(s2, n)), r3 && (f = true), !f && (e2 = wordReg.exec(s2)) && (g = true, e2[0].length > 1 && (o.words.push(e2[1]), o.lastAnyWord = e2[1], e2[2] && (o.lastWord = e2[2])), e2[0].length > 2 && (d += e2[0].length - 2));
      }
      if (a && (okFirstChars.test(s2) ? f = false : a = false), f) break;
    }
    h = y;
  }
  if (r) throw new SyntaxError("Unclosed '" + r + "'");
  return o && (o.oneliner = g), t.substring(0, d);
}
restOfExp.next = ["splitter", "expEnd", "inlineIf"];
var startingExecpted = ["initialize", "expSingle", "expFunction", "value", "modifier", "prop", "incrementerBefore", "expEnd"];
var setLispType = (e, t) => {
  e.forEach((e2) => {
    lispTypes.set(e2, t);
  });
};
var closingsCreate = { createArray: /^\]/, createObject: /^\}/, group: /^\)/, arrayProp: /^\]/, call: /^\)/ };
var typesCreate = { createArray: 12, createObject: 22, group: 23, arrayProp: 19, call: 5, prop: 1, "?prop": 20, "?call": 21 };
setLispType(["createArray", "createObject", "group", "arrayProp", "call"], (e, t, n, r, s, i) => {
  let o = emptyString;
  const a = [];
  let c = false, p = r[0].length;
  const l = p;
  for (; p < n.length && !c; ) o = restOfExp(e, n.substring(p), [closingsCreate[t], /^,/]), p += o.length, o.trim().length && a.push(o), "," !== n.char(p) ? c = true : p++;
  const d = ["value", "modifier", "prop", "incrementerBefore", "expEnd"];
  let u, f;
  switch (t) {
    case "group":
    case "arrayProp":
      u = lispifyExpr(e, n.substring(l, p));
      break;
    case "call":
    case "createArray":
      u = a.map((t2) => lispify(e, t2, [...d, "spreadArray"]));
      break;
    case "createObject":
      u = a.map((t2) => {
        let n2;
        t2 = t2.trimStart();
        let r2 = "";
        if (f = expectTypes.expFunction.types.function.exec("function " + t2), f) r2 = f[2].trimStart(), n2 = lispify(e, new CodeString("function " + t2.toString().replace(r2, "")));
        else {
          const s2 = restOfExp(e, t2, [/^:/]);
          r2 = lispify(e, s2, [...d, "spreadObject"]), 1 === r2[0] && (r2 = r2[2]), n2 = lispify(e, t2.substring(s2.length + 1));
        }
        return createLisp({ op: 6, a: r2, b: n2 });
      });
  }
  const h = "arrayProp" === t ? r[1] ? 20 : 1 : "call" === t ? r[1] ? 21 : 5 : typesCreate[t];
  i.lispTree = lispify(e, n.substring(p + 1), expectTypes[s].next, createLisp({ op: h, a: i.lispTree, b: u }));
});
var modifierTypes = { inverse: 64, not: 24, positive: 59, negative: 58, typeof: 60, delete: 61 };
setLispType(["inverse", "not", "negative", "positive", "typeof", "delete"], (e, t, n, r, s, i) => {
  const o = restOfExp(e, n.substring(r[0].length), [/^([^\s.?\w$]|\?[^.])/]);
  i.lispTree = lispify(e, n.substring(o.length + r[0].length), restOfExp.next, createLisp({ op: modifierTypes[t], a: i.lispTree, b: lispify(e, o, expectTypes[s].next) }));
});
var incrementTypes = { "++$": 25, "--$": 27, "$++": 26, "$--": 28 };
setLispType(["incrementerBefore"], (e, t, n, r, s, i) => {
  const o = restOfExp(e, n.substring(2), [/^[^\s.\w$]/]);
  i.lispTree = lispify(e, n.substring(o.length + 2), restOfExp.next, createLisp({ op: incrementTypes[r[0] + "$"], a: lispify(e, o, expectTypes[s].next), b: 0 }));
}), setLispType(["incrementerAfter"], (e, t, n, r, s, i) => {
  i.lispTree = lispify(e, n.substring(r[0].length), expectTypes[s].next, createLisp({ op: incrementTypes["$" + r[0]], a: i.lispTree, b: 0 }));
});
var adderTypes = { "&&": 29, "||": 30, instanceof: 62, in: 63, "=": 9, "-=": 65, "+=": 66, "/=": 67, "**=": 68, "*=": 69, "%=": 70, "^=": 71, "&=": 72, "|=": 73, ">>>=": 74, "<<=": 76, ">>=": 75 };
setLispType(["assign", "assignModify", "boolOp"], (e, t, n, r, s, i) => {
  i.lispTree = createLisp({ op: adderTypes[r[0]], a: i.lispTree, b: lispify(e, n.substring(r[0].length), expectTypes[s].next) });
});
var opTypes = { "&": 77, "|": 78, "^": 79, "<<": 80, ">>": 81, ">>>": 82, "<=": 54, ">=": 55, "<": 56, ">": 57, "!==": 31, "!=": 53, "===": 32, "==": 52, "+": 33, "-": 47, "/": 48, "**": 49, "*": 50, "%": 51 };
function extractIfElse(e, t) {
  let n, r, s = 0, i = t.substring(0, 0), o = emptyString, a = true, c = {};
  for (; (i = restOfExp(e, t.substring(i.end - t.start), [elseIf, ifElse, semiColon], void 0, void 0, void 0, c)).length || a; ) {
    a = false;
    const p = t.substring(i.end - t.start).toString();
    if (p.startsWith("if")) i.end++, s++;
    else if (p.startsWith("else")) n = t.substring(0, i.end - t.start), i.end++, s--, s || i.end--;
    else {
      if (!(r = /^;?\s*else(?![\w$])/.exec(p))) {
        n = o.length ? n : t.substring(0, i.end - t.start);
        break;
      }
      n = t.substring(0, i.end - t.start), i.end += r[0].length - 1, s--, s || (i.end -= r[0].length - 1);
    }
    if (!s) {
      o = extractIfElse(e, t.substring(i.end - t.start + (/^;?\s*else(?![\w$])/.exec(p)?.[0].length || 0))).all;
      break;
    }
    c = {};
  }
  return n = n || t.substring(0, i.end - t.start), { all: t.substring(0, Math.max(n.end, o.end) - t.start), true: n, false: o };
}
setLispType(["opHigh", "op", "comparitor", "bitwise"], (e, t, n, r, s, i) => {
  const o = [expectTypes.inlineIf.types.inlineIf, inlineIfElse];
  switch (t) {
    case "opHigh":
      o.push(expectTypes.splitter.types.opHigh);
    case "op":
      o.push(expectTypes.splitter.types.op);
    case "comparitor":
      o.push(expectTypes.splitter.types.comparitor);
    case "bitwise":
      o.push(expectTypes.splitter.types.bitwise), o.push(expectTypes.splitter.types.boolOp);
  }
  const a = restOfExp(e, n.substring(r[0].length), o);
  i.lispTree = lispify(e, n.substring(a.length + r[0].length), restOfExp.next, createLisp({ op: opTypes[r[0]], a: i.lispTree, b: lispify(e, a, expectTypes[s].next) }));
}), setLispType(["inlineIf"], (e, t, n, r, s, i) => {
  let o = false;
  const a = n.substring(0, 0);
  let c = 1;
  for (; !o && a.length < n.length; ) a.end = restOfExp(e, n.substring(a.length + 1), [expectTypes.inlineIf.types.inlineIf, inlineIfElse]).end, "?" === n.char(a.length) ? c++ : c--, c || (o = true);
  a.start = n.start + 1, i.lispTree = createLisp({ op: 15, a: i.lispTree, b: createLisp({ op: 16, a: lispifyExpr(e, a), b: lispifyExpr(e, n.substring(r[0].length + a.length + 1)) }) });
}), setLispType(["if"], (e, t, n, r, s, i) => {
  let o = restOfExp(e, n.substring(r[0].length), [], "(");
  const a = extractIfElse(e, n.substring(r[1].length)), c = r[0].length - r[1].length + o.length + 1;
  let p = a.true.substring(c), l = a.false;
  o = o.trim(), p = p.trim(), l = l.trim(), "{" === p.char(0) && (p = p.slice(1, -1)), "{" === l.char(0) && (l = l.slice(1, -1)), i.lispTree = createLisp({ op: 13, a: lispifyExpr(e, o), b: createLisp({ op: 14, a: lispifyBlock(p, e), b: lispifyBlock(l, e) }) });
}), setLispType(["switch"], (e, t, n, r, s, i) => {
  const o = restOfExp(e, n.substring(r[0].length), [], "(");
  let a = n.toString().indexOf("{", r[0].length + o.length + 1);
  if (-1 === a) throw new SyntaxError("Invalid switch");
  let c, p = insertSemicolons(e, restOfExp(e, n.substring(a + 1), [], "{"));
  const l = /^\s*(case\s|default)\s*/, d = [];
  let u = false;
  for (; c = l.exec(p.toString()); ) {
    if ("default" === c[1]) {
      if (u) throw new SyntaxError("Only one default switch case allowed");
      u = true;
    }
    const t2 = restOfExp(e, p.substring(c[0].length), [/^:/]);
    let n2 = emptyString, r2 = a = c[0].length + t2.length + 1;
    const s2 = /^\s*\{/.exec(p.substring(r2).toString());
    let i2 = [];
    if (s2) r2 += s2[0].length, n2 = restOfExp(e, p.substring(r2), [], "{"), r2 += n2.length + 1, i2 = lispifyBlock(n2, e);
    else {
      const t3 = restOfExp(e, p.substring(r2), [l]);
      if (t3.trim().length) {
        for (; (n2 = restOfExp(e, p.substring(r2), [semiColon])).length && (r2 += n2.length + (";" === p.char(r2 + n2.length) ? 1 : 0), !l.test(p.substring(r2).toString())); ) ;
        i2 = lispifyBlock(p.substring(a, n2.end - p.start), e);
      } else i2 = [], r2 += t3.length;
    }
    p = p.substring(r2), d.push(createLisp({ op: 41, a: "default" === c[1] ? 0 : lispifyExpr(e, t2), b: i2 }));
  }
  i.lispTree = createLisp({ op: 40, a: lispifyExpr(e, o), b: d });
}), setLispType(["dot", "prop"], (e, t, n, r, s, i) => {
  let o = r[0], a = r[0].length, c = "prop";
  if ("dot" === t) {
    r[1] && (c = "?prop");
    const e2 = n.substring(r[0].length).toString().match(expectTypes.prop.types.prop);
    if (!e2 || !e2.length) throw new SyntaxError("Hanging  dot");
    o = e2[0], a = o.length + r[0].length;
  }
  i.lispTree = lispify(e, n.substring(a), expectTypes[s].next, createLisp({ op: typesCreate[c], a: i.lispTree, b: o }));
}), setLispType(["spreadArray", "spreadObject"], (e, t, n, r, s, i) => {
  i.lispTree = createLisp({ op: "spreadArray" === t ? 18 : 17, a: 0, b: lispify(e, n.substring(r[0].length), expectTypes[s].next) });
}), setLispType(["return", "throw"], (e, t, n, r, s, i) => {
  i.lispTree = createLisp({ op: "return" === t ? 8 : 46, a: 0, b: lispifyExpr(e, n.substring(r[0].length)) });
}), setLispType(["number", "boolean", "null", "und", "NaN", "Infinity"], (e, t, n, r, s, i) => {
  i.lispTree = lispify(e, n.substring(r[0].length), expectTypes[s].next, createLisp({ op: "number" === t ? r[10] ? 83 : 7 : 35, a: 0, b: r[10] ? r[1] : r[0] }));
}), setLispType(["string", "literal", "regex"], (e, t, n, r, s, i) => {
  i.lispTree = lispify(e, n.substring(r[0].length), expectTypes[s].next, createLisp({ op: "string" === t ? 2 : "literal" === t ? 84 : 85, a: 0, b: r[1] }));
}), setLispType(["initialize"], (e, t, n, r, s, i) => {
  const o = "var" === r[1] ? 34 : "let" === r[1] ? 3 : 4;
  r[3] ? i.lispTree = createLisp({ op: o, a: r[2], b: lispify(e, n.substring(r[0].length), expectTypes[s].next) }) : i.lispTree = lispify(e, n.substring(r[0].length), expectTypes[s].next, createLisp({ op: o, a: r[2], b: 0 }));
}), setLispType(["function", "inlineFunction", "arrowFunction", "arrowFunctionSingle"], (e, t, n, r, s, i) => {
  const o = "function" !== t && "inlineFunction" !== t, a = o && !r[r.length - 1], c = o ? 2 : 3, p = r[1] ? 88 : 0, l = r[c] ? r[c].replace(/\s+/g, "").split(/,/g) : [];
  o || l.unshift((r[2] || "").trimStart());
  let d = false;
  l.forEach((e2) => {
    if (d) throw new SyntaxError("Rest parameter must be last formal parameter");
    e2.startsWith("...") && (d = true);
  });
  const u = restOfExp(e, n.substring(r[0].length), a ? [/^[,)}\]]/, semiColon] : [/^}/]), f = a ? "return " + u : u.toString();
  i.lispTree = lispify(e, n.substring(r[0].length + f.length + 1), expectTypes[s].next, createLisp({ op: o ? 11 : "function" === t ? 37 : 10, a: [p, ...l], b: e.eager ? lispifyFunction(new CodeString(f), e) : f }));
});
var iteratorRegex = /^((let|var|const)\s+)?\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s+(in|of)(?![\w$])/;
setLispType(["for", "do", "while"], (e, t, n, r, s, i) => {
  let o, a, c = 0, p = 88, l = [], d = 0, u = 0, f = 88, h = 88;
  switch (t) {
    case "while": {
      c = n.toString().indexOf("(") + 1;
      const t2 = restOfExp(e, n.substring(c), [], "(");
      o = lispifyReturnExpr(e, t2), a = restOfExp(e, n.substring(c + t2.length + 1)).trim(), "{" === a.char(0) && (a = a.slice(1, -1));
      break;
    }
    case "for": {
      c = n.toString().indexOf("(") + 1;
      const t2 = [];
      let r2, s2 = emptyString;
      for (let r3 = 0; r3 < 3 && (s2 = restOfExp(e, n.substring(c), [/^[;)]/]), t2.push(s2.trim()), c += s2.length + 1, ")" !== n.char(c - 1)); r3++) ;
      if (1 === t2.length && (r2 = iteratorRegex.exec(t2[0].toString()))) "of" === r2[4] ? (d = lispifyReturnExpr(e, t2[0].substring(r2[0].length)), l = [ofStart2, ofStart3], o = ofCondition, h = ofStep, u = lispify(e, new CodeString((r2[1] || "let ") + r2[3] + " = $$next.value"), ["initialize"])) : (d = lispifyReturnExpr(e, t2[0].substring(r2[0].length)), l = [inStart2, inStart3], h = inStep, o = inCondition, u = lispify(e, new CodeString((r2[1] || "let ") + r2[3] + " = $$keys[$$keyIndex]"), ["initialize"]));
      else {
        if (3 !== t2.length) throw new SyntaxError("Invalid for loop definition");
        p = lispifyExpr(e, t2.shift(), startingExecpted), o = lispifyReturnExpr(e, t2.shift()), h = lispifyExpr(e, t2.shift());
      }
      a = restOfExp(e, n.substring(c)).trim(), "{" === a.char(0) && (a = a.slice(1, -1));
      break;
    }
    case "do": {
      f = 0;
      const t2 = !!r[3];
      a = restOfExp(e, n.substring(r[0].length), t2 ? [/^\}/] : [semiColon]), o = lispifyReturnExpr(e, restOfExp(e, n.substring(n.toString().indexOf("(", r[0].length + a.length) + 1), [], "("));
      break;
    }
  }
  const g = [f, l, d, p, h, o, u];
  i.lispTree = createLisp({ op: 38, a: g, b: lispifyBlock(a, e) });
}), setLispType(["block"], (e, t, n, r, s, i) => {
  i.lispTree = createLisp({ op: 42, a: lispifyBlock(restOfExp(e, n.substring(1), [], "{"), e), b: 0 });
}), setLispType(["loopAction"], (e, t, n, r, s, i) => {
  i.lispTree = createLisp({ op: 86, a: r[1], b: 0 });
});
var catchReg = /^\s*(catch\s*(\(\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s*\))?|finally)\s*\{/;
setLispType(["try"], (e, t, n, r, s, i) => {
  const o = restOfExp(e, n.substring(r[0].length), [], "{");
  let a, c, p = catchReg.exec(n.substring(r[0].length + o.length + 1).toString()), l = "", d = 0;
  p[1].startsWith("catch") ? (p = catchReg.exec(n.substring(r[0].length + o.length + 1).toString()), l = p[2], c = restOfExp(e, n.substring(r[0].length + o.length + 1 + p[0].length), [], "{"), d = r[0].length + o.length + 1 + p[0].length + c.length + 1, (p = catchReg.exec(n.substring(d).toString())) && p[1].startsWith("finally") && (a = restOfExp(e, n.substring(d + p[0].length), [], "{"))) : a = restOfExp(e, n.substring(r[0].length + o.length + 1 + p[0].length), [], "{");
  const u = [l, lispifyBlock(insertSemicolons(e, c || emptyString), e), lispifyBlock(insertSemicolons(e, a || emptyString), e)];
  i.lispTree = createLisp({ op: 39, a: lispifyBlock(insertSemicolons(e, o), e), b: u });
}), setLispType(["void", "await"], (e, t, n, r, s, i) => {
  const o = restOfExp(e, n.substring(r[0].length), [/^([^\s.?\w$]|\?[^.])/]);
  i.lispTree = lispify(e, n.substring(r[0].length + o.length), expectTypes[s].next, createLisp({ op: "void" === t ? 87 : 44, a: lispify(e, o), b: 0 }));
}), setLispType(["new"], (e, t, n, r, s, i) => {
  let o = r[0].length;
  const a = restOfExp(e, n.substring(o), [], void 0, "(");
  o += a.length + 1;
  const c = [];
  if ("(" === n.char(o - 1)) {
    const t2 = restOfExp(e, n.substring(o), [], "(");
    let r2;
    o += t2.length + 1;
    let s2 = 0;
    for (; (r2 = restOfExp(e, t2.substring(s2), [/^,/])).length; ) s2 += r2.length + 1, c.push(r2.trim());
  }
  i.lispTree = lispify(e, n.substring(o), expectTypes.expEdge.next, createLisp({ op: 45, a: lispify(e, a, expectTypes.initialize.next), b: c.map((t2) => lispify(e, t2, expectTypes.initialize.next)) }));
});
var ofStart2 = lispify(void 0, new CodeString("let $$iterator = $$obj[Symbol.iterator]()"), ["initialize"]);
var ofStart3 = lispify(void 0, new CodeString("let $$next = $$iterator.next()"), ["initialize"]);
var ofCondition = lispify(void 0, new CodeString("return !$$next.done"), ["initialize"]);
var ofStep = lispify(void 0, new CodeString("$$next = $$iterator.next()"));
var inStart2 = lispify(void 0, new CodeString("let $$keys = Object.keys($$obj)"), ["initialize"]);
var inStart3 = lispify(void 0, new CodeString("let $$keyIndex = 0"), ["initialize"]);
var inStep = lispify(void 0, new CodeString("$$keyIndex++"));
var inCondition = lispify(void 0, new CodeString("return $$keyIndex < $$keys.length"), ["initialize"]);
function lispify(e, t, n, r, s = false) {
  if (r = r || NullLisp, n = n || expectTypes.initialize.next, void 0 === t) return r;
  const i = (t = t.trimStart()).toString();
  if (!t.length && !n.includes("expEnd")) throw new SyntaxError("Unexpected end of expression");
  if (!t.length) return r;
  const o = { lispTree: r };
  let a;
  for (const r2 of n) if ("expEnd" !== r2) {
    for (const n2 in expectTypes[r2].types) if ("expEnd" !== n2 && (a = expectTypes[r2].types[n2].exec(i))) {
      lastType = n2;
      try {
        lispTypes.get(n2)?.(e, n2, t, a, r2, o);
      } catch (e2) {
        if (s && e2 instanceof SyntaxError) throw new ParseError(e2.message, i);
        throw e2;
      }
      break;
    }
    if (a) break;
  }
  if (!a && t.length) {
    if (s) throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`, i);
    throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`);
  }
  return o.lispTree;
}
var startingExpectedWithoutSingle = startingExecpted.filter((e) => "expSingle" !== e);
function lispifyExpr(e, t, n) {
  if (!t.trimStart().length) return NullLisp;
  const r = [];
  let s, i = 0;
  if ((n = n || expectTypes.initialize.next).includes("expSingle") && testMultiple(t.toString(), Object.values(expectTypes.expSingle.types))) return lispify(e, t, ["expSingle"], void 0, true);
  for (n === startingExecpted && (n = startingExpectedWithoutSingle); (s = restOfExp(e, t.substring(i), [/^,/])).length; ) r.push(s.trimStart()), i += s.length + 1;
  if (1 === r.length) return lispify(e, t, n, void 0, true);
  if (n.includes("initialize")) {
    const s2 = expectTypes.initialize.types.initialize.exec(r[0].toString());
    if (s2) return createLisp({ op: 42, a: r.map((t2, n2) => lispify(e, n2 ? new CodeString(s2[1] + " " + t2) : t2, ["initialize"], void 0, true)), b: 0 });
    if (expectTypes.initialize.types.return.exec(r[0].toString())) return lispify(e, t, n, void 0, true);
  }
  const o = r.map((t2) => lispify(e, t2, n, void 0, true));
  return createLisp({ op: 43, a: o, b: 0 });
}
function lispifyReturnExpr(e, t) {
  return createLisp({ op: 8, a: 0, b: lispifyExpr(e, t) });
}
function lispifyBlock(e, t, n = false) {
  if (!(e = insertSemicolons(t, e)).trim().length) return [];
  const r = [];
  let s, i = 0, o = 0, a = {}, c = false, p = false;
  for (; (s = restOfExp(t, e.substring(i), [semiColon], void 0, void 0, void 0, a)).length && (p = !(!e.char(i + s.length) || ";" === e.char(i + s.length)), i += s.length + (p ? 0 : 1), /^\s*else(?![\w$])/.test(e.substring(i).toString()) || a.words?.includes("do") && /^\s*while(?![\w$])/.test(e.substring(i).toString()) ? c = true : (c = false, r.push(e.substring(o, i - (p ? 0 : 1))), o = i), a = {}, !n); ) ;
  return c && r.push(e.substring(o, i - (p ? 0 : 1))), r.map((e2) => e2.trimStart()).filter((e2) => e2.length).map((e2) => lispifyExpr(t, e2.trimStart(), startingExecpted));
}
function lispifyFunction(e, t, n = false) {
  if (!e.trim().length) return [];
  const r = lispifyBlock(e, t, n);
  return hoist(r), r;
}
function hoist(e, t = []) {
  if (isLisp(e)) {
    if (!isLisp(e)) return false;
    const [n, r, s] = e;
    if (39 === n || 13 === n || 38 === n || 40 === n) hoist(r, t), hoist(s, t);
    else if (34 === n) t.push(createLisp({ op: 34, a: r, b: 0 }));
    else if (37 === n && r[1]) return t.push(e), true;
  } else if (Array.isArray(e)) {
    const n = [];
    for (const r of e) hoist(r, t) || n.push(r);
    n.length !== e.length && (e.length = 0, e.push(...t, ...n));
  }
  return false;
}
var closingsNoInsertion = /^(\})\s*(catch|finally|else|while|instanceof)(?![\w$])/;
var colonsRegex = /^((([\w$\])"'`]|\+\+|--)\s*\r?\n\s*([\w$+\-!~]))|(\}\s*[\w$!~+\-{("'`]))/;
function insertSemicolons(e, t) {
  let n = t, r = emptyString, s = {};
  const i = insertedSemicolons.get(t.ref) || new Array(t.ref.str.length);
  for (; (r = restOfExp(e, n, [], void 0, void 0, [colonsRegex], s)).length; ) {
    let e2 = false, t2 = r, o = r.length;
    if (s.regRes) {
      e2 = true;
      const [, , i2, , , a] = s.regRes;
      if (o = "++" === s.regRes[3] || "--" === s.regRes[3] ? r.length + 1 : r.length, t2 = n.substring(0, o), a) {
        const t3 = closingsNoInsertion.exec(n.substring(r.length - 1).toString());
        t3 ? e2 = "while" === t3[2] && "do" !== s.lastWord : "function" === s.lastWord && "}" === s.regRes[5][0] && "(" === s.regRes[5].slice(-1) && (e2 = false);
      } else i2 && ("if" !== s.lastWord && "while" !== s.lastWord && "for" !== s.lastWord && "else" !== s.lastWord || (e2 = false));
    }
    e2 && (i[t2.end] = true), n = n.substring(o), s = {};
  }
  return insertedSemicolons.set(t.ref, i), t;
}
function checkRegex(e) {
  let t = 1, n = false, r = false, s = false;
  for (; t < e.length && !r && !s; ) r = "/" === e[t] && !n, n = "\\" === e[t] && !n, s = "\n" === e[t], t++;
  const i = e.substring(t);
  if (s = s || !r || /^\s*\d/.test(i), s) return null;
  const o = /^[a-z]*/.exec(i);
  return /^\s+[\w$]/.test(e.substring(t + o[0].length)) ? null : { regex: e.substring(1, t - 1), flags: o && o[0] || "", length: t + (o && o[0].length || 0) };
}
var notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/;
var possibleDivide = /^([\w$\])]|\+\+|--)[\s/]/;
function extractConstants(e, t, n = "") {
  let r, s, i = [], o = false, a = "", c = -1, p = [], l = "";
  const d = [], u = [];
  let f = null, h = 0;
  for (h = 0; h < t.length; h++) if (l = t[h], a) l === a && ("*" === a && "/" === t[h + 1] ? (a = "", h++) : "\n" === a && (a = ""));
  else {
    if (o) {
      o = false, i.push(l);
      continue;
    }
    if (r) if ("`" === r && "$" === l && "{" === t[h + 1]) {
      const n2 = extractConstants(e, t.substring(h + 2), "{");
      p.push(n2.str), i.push("${", p.length - 1, "}"), h += n2.length + 2;
    } else if (r === l) {
      if ("`" === r) {
        const t2 = createLisp({ op: 36, a: unraw(i.join("")), b: [] });
        t2.tempJsStrings = p, e.literals.push(t2), d.push("`", e.literals.length - 1, "`");
      } else e.strings.push(unraw(i.join(""))), d.push('"', e.strings.length - 1, '"');
      r = null, i = [];
    } else i.push(l);
    else {
      if ("'" === l || '"' === l || "`" === l) p = [], r = l;
      else {
        if (closings[n] === l && !u.length) return { str: d.join(""), length: h };
        closings[l] ? (u.push(l), d.push(l)) : closings[u[u.length - 1]] === l ? (u.pop(), d.push(l)) : "/" !== l || "*" !== t[h + 1] && "/" !== t[h + 1] ? "/" === l && !f && (s = checkRegex(t.substring(h))) ? (e.regexes.push(s), d.push("/", e.regexes.length - 1, "/r"), h += s.length - 1) : d.push(l) : (a = "*" === t[h + 1] ? "*" : "\n", c = h);
      }
      f && space.test(l) || (f = possibleDivide.exec(t.substring(h))) && notDivide.test(t.substring(0, h + f[1].length)) && (f = null);
    }
    o = !(!r || "\\" !== l);
  }
  if (a && "*" === a) throw new SyntaxError(`Unclosed comment '/*': ${t.substring(c)}`);
  return { str: d.join(""), length: h };
}
function parse(e, t = false, n = false) {
  if ("string" != typeof e) throw new ParseError(`Cannot parse ${e}`, e);
  let r = " " + e;
  const s = { strings: [], literals: [], regexes: [], eager: t };
  r = extractConstants(s, r).str;
  for (const e2 of s.literals) e2[2] = e2.tempJsStrings.map((e3) => lispifyExpr(s, new CodeString(e3))), delete e2.tempJsStrings;
  return { tree: lispifyFunction(new CodeString(r), s, n), constants: s };
}
function createEvalContext() {
  return { sandboxFunction, sandboxedEval, sandboxedSetTimeout, sandboxedSetInterval, lispifyFunction };
}
function sandboxFunction(e, t) {
  return function SandboxFunction(...n) {
    const r = parse(n.pop() || "");
    return createFunction(n, r.tree, t || currentTicks.current, { ...e, constants: r.constants, tree: r.tree }, void 0, "anonymous");
  };
}
function sandboxedEval(e) {
  return function(t) {
    return e(t)();
  };
}
function sandboxedSetTimeout(e) {
  return function(t, ...n) {
    return "string" != typeof t ? setTimeout(t, ...n) : setTimeout(e(t), ...n);
  };
}
function sandboxedSetInterval(e) {
  return function(t, ...n) {
    return "string" != typeof t ? setInterval(t, ...n) : setInterval(e(t), ...n);
  };
}
function subscribeSet(e, t, n, r) {
  if (!(e instanceof Object)) throw new Error("Invalid subscription object, got " + ("object" == typeof e ? "null" : typeof e));
  const s = r.setSubscriptions.get(e) || /* @__PURE__ */ new Map();
  r.setSubscriptions.set(e, s);
  const i = s.get(t) || /* @__PURE__ */ new Set();
  let o;
  s.set(t, i), i.add(n);
  const a = e[t];
  return a instanceof Object && (o = r.changeSubscriptions.get(a) || /* @__PURE__ */ new Set(), o.add(n), r.changeSubscriptions.set(a, o)), { unsubscribe: () => {
    i.delete(n), o?.delete(n);
  } };
}
var SandboxExec = class _SandboxExec {
  constructor(e, t) {
    this.evalContext = t, this.setSubscriptions = /* @__PURE__ */ new WeakMap(), this.changeSubscriptions = /* @__PURE__ */ new WeakMap(), this.sandboxFunctions = /* @__PURE__ */ new WeakMap();
    const n = Object.assign({ audit: false, forbidFunctionCalls: false, forbidFunctionCreation: false, globals: _SandboxExec.SAFE_GLOBALS, prototypeWhitelist: _SandboxExec.SAFE_PROTOTYPES, prototypeReplacements: /* @__PURE__ */ new Map() }, e || {});
    this.context = createContext(this, n);
  }
  static get SAFE_GLOBALS() {
    return { Function, console: { debug: console.debug, error: console.error, info: console.info, log: console.log, table: console.table, warn: console.warn }, isFinite, isNaN, parseFloat, parseInt, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, escape, unescape, Boolean, Number, BigInt, String, Object, Array, Symbol, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Map, Set, WeakMap, WeakSet, Promise, Intl, JSON, Math, Date, RegExp };
  }
  static get SAFE_PROTOTYPES() {
    const e = [SandboxGlobal, Function, Boolean, Number, BigInt, String, Date, Error, Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Map, Set, WeakMap, WeakSet, Promise, Symbol, Date, RegExp], t = /* @__PURE__ */ new Map();
    return e.forEach((e2) => {
      t.set(e2, /* @__PURE__ */ new Set());
    }), t.set(Object, /* @__PURE__ */ new Set(["entries", "fromEntries", "getOwnPropertyNames", "is", "keys", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf", "values"])), t;
  }
  subscribeGet(e, t) {
    return t.getSubscriptions.add(e), { unsubscribe: () => t.getSubscriptions.delete(e) };
  }
  subscribeSet(e, t, n, r) {
    return subscribeSet(e, t, n, r);
  }
  subscribeSetGlobal(e, t, n) {
    return subscribeSet(e, t, n, this);
  }
  getContext(e) {
    return this.sandboxFunctions.get(e);
  }
  executeTree(e, t = []) {
    return executeTree({ ticks: BigInt(0) }, e, e.tree, t);
  }
  executeTreeAsync(e, t = []) {
    return executeTreeAsync({ ticks: BigInt(0) }, e, e.tree, t);
  }
};
var Sandbox = class extends SandboxExec {
  constructor(e) {
    super(e, createEvalContext());
  }
  static audit(e, t = []) {
    const n = {};
    for (const e2 of Object.getOwnPropertyNames(globalThis)) n[e2] = globalThis[e2];
    const r = new SandboxExec({ globals: n, audit: true });
    return r.executeTree(createExecContext(r, parse(e, true), createEvalContext()), t);
  }
  static parse(e) {
    return parse(e);
  }
  compile(e, t = false) {
    const n = parse(e, t);
    return (...e2) => {
      const t2 = createExecContext(this, n, this.evalContext);
      return { context: t2, run: () => this.executeTree(t2, [...e2]).result };
    };
  }
  compileAsync(e, t = false) {
    const n = parse(e, t);
    return (...e2) => {
      const t2 = createExecContext(this, n, this.evalContext);
      return { context: t2, run: () => this.executeTreeAsync(t2, [...e2]).then((e3) => e3.result) };
    };
  }
  compileExpression(e, t = false) {
    const n = parse(e, t, true);
    return (...e2) => {
      const t2 = createExecContext(this, n, this.evalContext);
      return { context: t2, run: () => this.executeTree(t2, [...e2]).result };
    };
  }
  compileExpressionAsync(e, t = false) {
    const n = parse(e, t, true);
    return (...e2) => {
      const t2 = createExecContext(this, n, this.evalContext);
      return { context: t2, run: () => this.executeTreeAsync(t2, [...e2]).then((e3) => e3.result) };
    };
  }
};

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src-web/dsl.ts
var DslErrors;
((DslErrors2) => {
  class PerfectHedgeError extends Error {
    state;
    amount;
    partyIdx;
    pair;
    constructor(msg, st, amount, partyIdx, pair) {
      super(msg);
      this.state = st;
      this.amount = amount;
      this.partyIdx = partyIdx;
      this.pair = pair;
    }
  }
  DslErrors2.PerfectHedgeError = PerfectHedgeError;
  class InfinityError extends Error {
    state = void 0;
    constructor(msg, st) {
      super(msg);
      this.state = st;
    }
  }
  DslErrors2.InfinityError = InfinityError;
  class InfinityCountError extends Error {
  }
  DslErrors2.InfinityCountError = InfinityCountError;
  class PartyAtAdvantage extends Error {
    amount;
    partyIdx;
    pair;
    constructor(msg, amount, partyIdx, pair) {
      super(msg);
      this.amount = amount;
      this.partyIdx = partyIdx;
      this.pair = pair;
    }
  }
  DslErrors2.PartyAtAdvantage = PartyAtAdvantage;
  class OnePayPerCondition extends Error {
    amount;
    partyIdx;
    pair;
    state;
    constructor(msg, amount, partyIdx, pair, state) {
      super(msg);
      this.amount = amount;
      this.partyIdx = partyIdx;
      this.pair = pair;
      this.state = state;
    }
  }
  DslErrors2.OnePayPerCondition = OnePayPerCondition;
  class ComplexConditions extends Error {
    amount;
    partyIdx;
    pair;
    constructor(msg, amount, partyIdx, pair) {
      super(msg);
      this.amount = amount;
      this.partyIdx = partyIdx;
      this.pair = pair;
    }
  }
  DslErrors2.ComplexConditions = ComplexConditions;
  class EmptyDslOutput extends Error {
  }
  DslErrors2.EmptyDslOutput = EmptyDslOutput;
})(DslErrors || (DslErrors = {}));
var Dsl = class {
  state = {};
  template() {
    const model = {
      id: "",
      bet: [0, 0],
      betOn: void 0,
      oracles: [],
      question: "",
      status: "matching",
      blockchain: "",
      role: "initiator"
    };
    return model;
  }
  root = this.template();
  cursor = this.root;
  prev = void 0;
  lastOutcome = void 0;
  flag = false;
  alicePayCounter = 0;
  bobPayCounter = 0;
  aliceTrackers = {};
  bobTrackers = {};
  pay(idx, amount) {
    if (this.unssafeInifnityCtx) {
      throw new Error("Payouts are disabled in unsafe infinity context. Specify cashflows in return instead");
    }
    if (idx === void 0) {
      throw new Error("party undefined");
    }
    if (!this.protect) {
      throw new Error("should not call outside of body; use `new Dsl((dsl) => handler).enumerate()`");
    }
    if (this.prev === void 0 || this.lastOutcome === void 0) {
      new Error("cannot pay unconditionally!");
    }
    if (amount <= 0) {
      throw Error("Pay amount must be positive! found: " + amount);
    }
    if (this.lastOutcome !== null) {
      if (this.lastOutcome && idx === 0) {
        if (this.prev.betOn === void 0 || this.prev.betOn === true) {
          this.prev.betOn = true;
        } else {
          throw new DslErrors.PerfectHedgeError("Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!", this.state, amount, idx, this.selected);
        }
      }
      if (!this.lastOutcome && idx === 0) {
        if (this.prev.betOn === void 0 || this.prev.betOn === false) {
          this.prev.betOn = false;
        } else {
          throw new DslErrors.PerfectHedgeError("Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!", this.state, amount, idx, this.selected);
        }
      }
    }
    if (this.lastOutcome !== null) {
      if (this.lastOutcome && idx === 1) {
        if (this.prev.betOn === void 0 || this.prev.betOn === false) {
          this.prev.betOn = false;
        } else {
          throw new DslErrors.PerfectHedgeError("Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!", this.state, amount, idx, this.selected);
        }
      }
      if (!this.lastOutcome && idx === 1) {
        if (this.prev.betOn === void 0 || this.prev.betOn === true) {
          this.prev.betOn = true;
        } else {
          throw new DslErrors.PerfectHedgeError("Perfect hedge! Trader not allowed to benefit regardless of outcome. Your trade is overcollaterized!", this.state, amount, idx, this.selected);
        }
      }
    }
    if (this.flag) {
      throw new Error(`one pay per condition check! and pay before checking out next condition too, please!
at amount = ${amount}; idx = ${idx}; pair = ${this.selected}`);
    }
    if (idx == 0) {
      this.alicePayCounter++;
      this.prev.bet[1] = Math.round(amount);
    } else {
      this.bobPayCounter++;
      this.prev.bet[0] = Math.round(amount);
    }
    this.flag = true;
    if (idx === 0) {
      this.collateral1 += amount;
      if (this.collateral1 > this.budgetBound1) {
        const party = this.selected[0] ?? "Alice";
        throw new Error(`exceeded budget ${this.budgetBound1} for ${party}, for outcomes:` + JSON.stringify(this.state));
      }
    }
    if (idx === 1) {
      this.collateral2 += amount;
      if (this.collateral2 > this.budgetBound2) {
        const party = this.selected[1] ?? "Bob";
        throw new Error(`exceeded budget ${this.budgetBound2} for ${party}, for outcomes:` + JSON.stringify(this.state));
      }
    }
  }
  enrichAndProgress(aliceOutcome, pubkey, yes, no, args = {}) {
    this.lastOutcome = aliceOutcome;
    this.flag = false;
    if (aliceOutcome === false) {
      if (this.cursor.ifCounterPartyWins === void 0) {
        this.cursor.ifCounterPartyWins = this.template();
      } else {
        const x = this.cursor.ifCounterPartyWins.bet;
        this.cursor.ifCounterPartyWins.bet = [x[0] === null ? 0 : x[0], x[0] === null ? 0 : x[0]];
      }
      this.prev = this.cursor;
      this.cursor = this.cursor.ifCounterPartyWins;
    } else if (aliceOutcome === true) {
      if (this.cursor.ifPartyWins === void 0) {
        this.cursor.ifPartyWins = this.template();
      } else {
        const x = this.cursor.ifPartyWins.bet;
        this.cursor.ifPartyWins.bet = [x[0] === null ? 0 : x[0], x[0] === null ? 0 : x[0]];
      }
      this.prev = this.cursor;
      this.cursor = this.cursor.ifPartyWins;
    }
    if (this.prev) {
      this.prev.oracles[0] = {
        capabilityPub: pubkey.replaceAll(/-###-.*/g, ""),
        params: args
      };
      this.prev.yesOutcomes = yes;
      this.prev.noOutcomes = no;
    }
  }
  counter = 0;
  memoize = [];
  checked = [];
  superMode = false;
  megaMode = false;
  megaModeStarted = false;
  superModeStarted = false;
  fairModeStarted = false;
  strictModeStarted = false;
  security = {
    startMegaMode: () => {
      if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {
        throw new Error("Mega mode has to be started before any payouts or observations happen!");
      }
      if (this.megaMode) {
        throw new Error("Mega mode already enabled manually!");
      }
      this.megaModeStarted = true;
      this.megaMode = true;
    },
    startSuperMode: () => {
      if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {
        throw new Error("Super mode has to be started before any payouts or observations happen!");
      }
      if (this.superMode) {
        throw new Error("Super mode already enabled manually!");
      }
      this.superModeStarted = true;
      this.superMode = true;
    },
    startFairMode: () => {
      if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {
        throw new Error("Fair mode has to be started before any payouts or observations happen!");
      }
      if (this.megaMode) {
        throw new Error("Fair mode already enabled manually!");
      }
      this.fairModeStarted = true;
      this.strictlyFair = true;
    },
    startStrictMode: () => {
      if (this.collateral1 > 0 && this.collateral2 > 0 && this.counter > 0) {
        throw new Error("Strict mode has to be started before any payouts or observations happen!");
      }
      if (this.megaMode) {
        throw new Error("Strict mode already enabled manually!");
      }
      this.strictModeStarted = true;
      this.strictlyStrict = true;
    }
  };
  insecurity = {
    open: {
      disableMegaMode: () => {
        if (this.megaModeStarted) {
          throw new Error("Mega mode has to be started with `startMegaMode`!");
        }
        if (!this.megaMode) {
          throw new Error("Mega mode has to be enabled first!");
        }
        this.megaMode = false;
      },
      disableSuperMode: () => {
        if (this.superModeStarted) {
          throw new Error("Super mode has to be started with `startSuperMode`!");
        }
        if (!this.superMode) {
          throw new Error("Super mode has to be enabled first!");
        }
        this.superMode = false;
      }
    },
    close: {
      enableMegaMode: () => {
        if (this.megaModeStarted) {
          throw new Error("Mega mode has to be started with `startMegaMode`!");
        }
        if (this.megaMode) {
          throw new Error("Mega mode has to be disabled first!");
        }
        this.megaMode = false;
      },
      enableSuperMode: () => {
        if (this.superModeStarted) {
          throw new Error("Mega mode has to be started with `startMegaMode`!");
        }
        if (this.superMode) {
          throw new Error("Mega mode has to be disabled first!");
        }
        this.superMode = false;
      }
    }
  };
  strictlyOneLeafPays = false;
  strictlyOneLeafPairPays = false;
  outcome(pubkey, yes, no, args = {}, allowTruth = false, strict = true) {
    const pubkeyUnique = pubkey + "-###-" + JSON.stringify(yes) + JSON.stringify(no) + JSON.stringify(args);
    if (this.ignoreObserveChecks) {
      if (!this.state[pubkeyUnique]) {
        throw new Error("Did not find state while editing the tree: " + pubkeyUnique + "\n" + this.state);
      }
      return this.state[pubkeyUnique][1];
    }
    yes.sort();
    no.sort();
    this.counter++;
    if (new Set(yes).size !== yes.length) {
      throw Error("Duplicate outcomes:" + JSON.stringify(yes) + "; pubkey: " + pubkey);
    }
    if (new Set(no).size !== no.length) {
      throw Error("Duplicate outcomes: " + JSON.stringify(no)) + "; pubkey: " + pubkey;
    }
    if (strict && (yes.length === 0 || no.length === 0)) {
      throw Error("One of the outcome sets is empty. Trader would possibly benefit regardless of outcome. Use `dsl.unsafe` to allow!; pubkey: " + pubkey);
    }
    if (yes.length === 0 && no.length === 0) {
      throw Error("Transaction race! Outcomes are empty. Trader cannot benefit regardless of outcome. Use `dsl.unsafe` with synthetic outcome (convention: btc script generated outcomes should start with $, e.g. $(thisTx.utxo[0])) to allow!; pubkey: " + pubkey);
    }
    if (JSON.stringify(yes) === JSON.stringify(no) && !allowTruth) {
      throw Error("Contradiction! Outcomes are not mutually exclusive!; pubkey: " + pubkey);
    }
    const yesSet = new Set(yes);
    const noSet = new Set(no);
    if (yes.find((x) => noSet.has(x)) || no.find((x) => yesSet.has(x))) {
      if (strict) {
        throw Error("Partial contradiction! Some outcomes are not mutually exclusive!; pubkey: " + pubkey);
      }
    }
    if (!this.protect) {
      throw "should not call outside of body; use `new Dsl((dsl) => handler).enumerate()`; pubkey: " + pubkey;
    }
    if (this.state[pubkeyUnique] === void 0) {
      const max = Object.values(this.state).length === 0 ? -1 : Math.max(...Object.values(this.state).map((x) => x[0]));
      this.state[pubkeyUnique] = [max + 1, null, args];
      this.checked.push(this.state[pubkeyUnique][0]);
      this.memoize.push({
        id: pubkey,
        yes,
        no,
        args,
        pubkeyUnique
      });
      throw "uninitialized";
    } else {
      this.checked.push(this.state[pubkeyUnique][0]);
      if (this.memoize.find((x) => x.id === pubkey && JSON.stringify(x.yes.sort()) === JSON.stringify(yes.sort()) && JSON.stringify(x.no.sort()) === JSON.stringify(no.sort()) && JSON.stringify(x.args) === JSON.stringify(args)) !== void 0) {
        throw new Error("Cannot query same observation twice. Save it into const instead: const obs1 = outcome(...); args=" + JSON.stringify(args) + "; pubkey: " + pubkey);
      }
      const sameQuery = this.memoize.find((x) => x.id === pubkey);
      if (strict && sameQuery && JSON.stringify(sameQuery.yes.concat(sameQuery.no).sort()) !== JSON.stringify(yes.concat(no).sort())) {
        throw new Error("Set of overall outcomes must be same, regardless of parameters! " + sameQuery.yes.concat(sameQuery.no).sort() + " != " + yes.concat(no).sort() + "; pubkey: " + pubkey);
      }
      if (this.superMode && sameQuery && JSON.stringify(sameQuery.args) === JSON.stringify(sameQuery.args)) {
        throw new Error("Cannot query same observation twice! Super strictly! Arguments are allowed to vary; pubkey: " + pubkey);
      }
      if (this.megaMode && sameQuery) {
        throw new Error("Cannot query same observation twice! MEGA strictly!");
      }
      const contradiction = this.memoize.find((x) => x.id === pubkey && JSON.stringify(x.yes.sort()) === JSON.stringify(no.sort()) && JSON.stringify(x.no.sort()) === JSON.stringify(yes.sort()) && JSON.stringify(x.args) === JSON.stringify(args));
      if (contradiction !== void 0) {
        throw new Error("Cannot query the opposite of checked observation. Save it into const and inverse instead: const obs1 = outcome(...); const obs2 = !obs1; pubkey: " + pubkey);
      }
      this.enrichAndProgress(this.state[pubkeyUnique][1], pubkeyUnique, yes, no, args);
      this.memoize.push({
        id: pubkey,
        yes,
        no,
        args,
        pubkeyUnique
      });
      return this.state[pubkeyUnique][1];
    }
  }
  next() {
    this.cursor = this.root;
    this.prev = void 0;
    let i = 0;
    let cursor = true;
    let entry = void 0;
    while (cursor) {
      if (Object.values(this.state).find((x) => x[0] === i) === void 0) {
        return false;
      }
      entry = Object.values(this.state).find((x) => x[0] === i);
      if (entry[1] === null && cursor) {
        entry[1] = false;
        return true;
      }
      if (!cursor) {
        return true;
      }
      if (entry[1] === true) {
        if (cursor === true) {
          entry[1] = false;
        }
      } else {
        entry[1] = true;
        cursor = false;
      }
      i++;
    }
    return true;
  }
  body;
  constructor(body) {
    this.body = body;
  }
  protect = false;
  static Party = 0;
  static CounterParty = 1;
  static Alice = 0;
  static Bob = 1;
  collateral1 = 0;
  collateral2 = 0;
  budgetBound1 = 0;
  budgetBound2 = 0;
  leafsFiltered = false;
  strictlyStrict = false;
  filterLeafs(model, assertNoZeros = false) {
    if (model === void 0) {
      throw new DslErrors.EmptyDslOutput("Empty DSL model output!");
    }
    if (!model.bet[0] && !model.bet[1] && !model.ifPartyWins && !model.ifCounterPartyWins) {
      this.leafsFiltered = true;
      return void 0;
    }
    if (this.strictlyFair) {
      if (!model.bet[0] && model.bet[1]) {
        throw new DslErrors.PartyAtAdvantage("Party at advantage - no premium/discount introduced", model.bet[1], 0, this.selected);
      }
      if (model.bet[0] && !model.bet[1]) {
        throw new DslErrors.PartyAtAdvantage("Party at advantage - no premium/discount introduced", model.bet[0], 1, this.selected);
      }
    }
    if (assertNoZeros) {
      if (!model.bet[0] && !model.bet[1]) {
        throw new DslErrors.ComplexConditions("Strict Semantics of observation: complex conditions are disallowed!", model.bet[0], 1, this.selected);
      }
    }
    if (model.ifPartyWins) {
      model.ifPartyWins = this.filterLeafs(model.ifPartyWins);
    }
    if (model.ifCounterPartyWins) {
      model.ifCounterPartyWins = this.filterLeafs(model.ifCounterPartyWins);
    }
    if (!model.ifPartyWins) {
      delete model.ifPartyWins;
    }
    if (!model.ifCounterPartyWins) {
      delete model.ifCounterPartyWins;
    }
    return model;
  }
  multiparty = [];
  selected = [void 0, void 0];
  isSelected0 = (party) => {
    return this.selected[0] && this.selected[0] === party;
  };
  isSelected1 = (party) => {
    return this.selected[0] && this.selected[1] === party;
  };
  multiple = (...parties) => {
    if (this.multiparty.length > 0) {
      throw Error("parties can be specified only once! Adding more parties ad-hoc is equivalent to early termination since consensus is required for that! \n It is advised to create a new contract. \n Note: you can freely parametrize Discreet contracts (terms) and use factories to easily spawn contracts with additional parties.");
    }
    if (parties.length < 2) {
      throw Error("Commmon sense! Minimum of 2 parties required for a contract!");
    }
    const set = [...new Set(parties)];
    if (set.length < parties.length) {
      throw Error("Tractable relations! parties have to be unique!");
    }
    this.multiparty = parties;
    return this;
  };
  party = (partyName, partyAsset) => ({
    pays: (counterpartyName, counterpartyAsset) => ({
      amount: (amount, asset) => {
        if (partyName === void 0) {
          throw Error("Party undefined");
        }
        if (counterpartyName === void 0) {
          throw Error("Counter-party undefined");
        }
        const party = partyName + (partyAsset ? "_" + partyAsset : "");
        const counterparty = counterpartyName + (counterpartyAsset ? "_" + counterpartyAsset : "");
        if (partyAsset !== asset) {
          throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`);
        }
        if (!this.multiparty.find((x) => x === party)) {
          throw Error("party " + party + " not registered! Use .multiple to register parties");
        }
        if (!this.multiparty.find((x) => x === counterparty)) {
          throw Error("counterparty " + counterparty + " not registered! Use .multiple to register parties");
        }
        if (this.isSelected0(party) && this.isSelected1(counterparty)) {
          this.pay(0, amount);
        } else if (this.isSelected0(counterparty) && this.isSelected1(party)) {
          this.pay(1, amount);
        }
      }
    })
  });
  static account(partyName, partyAsset) {
    return partyName + "_" + partyAsset;
  }
  static mutual(...parties) {
    return parties.join("+");
  }
  static refund(party) {
    return party + "_refund";
  }
  unfinalized = 0;
  static track = {};
  static recurse = {
    bounded: (fn) => ({
      attempts: (attempts) => ({
        otherwiseYield: (defaultValue) => {
          if (!this.track[fn.toString()]) {
            this.track[fn.toString()] = 0;
          }
          return () => {
            this.track[fn.toString()] = this.track[fn.toString()] + 1;
            if (this.track[fn.toString()] > attempts) {
              return defaultValue;
            }
            return fn();
          };
        }
      })
    })
  };
  strictlyFair = false;
  unssafeInifnityCtx = false;
  unsafe = {
    if: (pubkey, yes, no, args = {}, allowSwaps = false, allowMisplacedPay = true, strict = false) => {
      return this.if(pubkey, yes, no, args, allowSwaps, allowMisplacedPay, strict);
    },
    numeric: {
      outcome: (pubkey, from, to, step = 1, args = {}, allowMisplacedPay = true, allowFork = true) => {
        return this.numeric.outcome(pubkey, from, to, step, args, allowMisplacedPay, allowFork);
      },
      infinity: {
        bounded: (maxInfinity = 1e7, maxCount = 1e9) => ({
          progress: (start, forward = (x) => x + 1) => ({
            perpetual: (init, step) => {
              this.unsafe.infinity.bounded(maxInfinity, maxCount).compare((a, b) => a - b).progress(start, forward).perpetual(init, step);
            }
          }),
          perpetual: (init, step) => {
            this.unsafe.infinity.bounded(maxInfinity, maxCount).compare((a, b) => b - a).progress(0, (x) => x + 1).perpetual(init, step);
          }
        })
      }
    },
    set: {
      outcome: (pubkey, set, args = {}, allowMisplacedPay = true, allowFork = true) => {
        return this.set.outcome(pubkey, set, args, allowMisplacedPay, allowFork);
      },
      outcomeT: (pubkey, set, renderer, args = {}, allowMisplacedPay = true, allowFork = true) => {
        return this.set.outcomeT(pubkey, set, renderer, args, allowMisplacedPay, allowFork);
      }
    },
    ifAtomicSwapLeg1: (lock = "TRUTH", unlockOutcome = "true", allowMisplacedPay = true) => {
      return this.if(lock, [unlockOutcome], [unlockOutcome], {}, true, allowMisplacedPay, false);
    },
    outcome: (pubkey, yes, no, args = {}, allowTruth = false, strict = false) => {
      return this.outcome(pubkey, yes, no, args, allowTruth, strict);
    },
    infinity: {
      move: (x) => {
        if (x === void 0) {
          throw new Error("Cannot move with undefined state!");
        }
        return x;
      },
      stop: (cashflows) => [void 0, cashflows],
      bounded: (maxInfinity, maxCount = 1e4) => ({
        compare: (cmp) => ({
          progress: (start, forward) => ({
            perpetual: (init, step) => {
              let cursor = start;
              let counter = 0;
              let state = init;
              this.unssafeInifnityCtx = true;
              try {
                while (cmp(cursor, maxInfinity) > 0 && counter < maxCount) {
                  const saveState = state;
                  let cashflows = void 0;
                  [state, cashflows] = step(cursor, state);
                  cashflows.forEach((cashflow) => {
                    try {
                      this.party(
                        cashflow.from[0],
                        cashflow.from[1]
                      ).pays(
                        cashflow.to[0],
                        cashflow.to[1]
                      ).amount(
                        cashflow.amount[0],
                        cashflow.amount[1]
                      );
                    } catch (e) {
                      if (e instanceof DslErrors.PerfectHedgeError) {
                        const party = e.pair[e.partyIdx];
                        state[party] = saveState[party];
                      }
                    }
                  });
                  if (state === void 0) {
                    return;
                  }
                  if (state === saveState) {
                    throw new DslErrors.InfinityError("Infinity Inferred! State did not progress! Collaterals are not decreasing?", state);
                  }
                  cursor = forward(cursor);
                  counter++;
                }
                if (counter >= maxCount) {
                  throw new DslErrors.InfinityCountError("Max count reached!");
                }
                if (cmp(cursor, maxInfinity) <= 0) {
                  throw new DslErrors.InfinityError("Infinity Reached! Collaterals are not decreasing?", state);
                }
              } finally {
                this.unssafeInifnityCtx = false;
              }
            }
          })
        })
      })
    }
  };
  infinity = {
    move: (x) => {
      if (x === void 0) {
        throw new Error("Cannot move with undefined state!");
      }
      return x;
    },
    stop: void 0,
    bounded: (maxInfinity, maxCount = 1e4) => ({
      compare: (cmp) => ({
        progress: (start, forward) => ({
          perpetual: (init, step) => {
            let cursor = start;
            let counter = 0;
            let state = init;
            while (cmp(cursor, maxInfinity) > 0 && counter < maxCount) {
              const saveState = state;
              state = step(cursor, state);
              if (state === void 0) {
                return;
              }
              if (state === saveState) {
                throw new DslErrors.InfinityError("Infinity Inferred! State did not progress! Collaterals are not decreasing?", state);
              }
              cursor = forward(cursor);
              counter++;
            }
            if (counter >= maxCount) {
              throw new DslErrors.InfinityCountError("Max count reached!");
            }
            if (cmp(cursor, maxInfinity) <= 0) {
              throw new DslErrors.InfinityError("Infinity Reached! Collaterals are not decreasing?", state);
            }
          }
        })
      })
    })
  };
  ignoreObserveChecks = false;
  bool = {
    safe: {
      outcome: (pubkey, yes, no, args = {}) => {
        return this.outcome(pubkey, [yes], [no], args);
      }
    }
  };
  numeric = {
    infinity: {
      bounded: (maxInfinity = 1e7, maxCount = 1e9) => ({
        progress: (start, forward = (x) => x + 1) => ({
          perpetual: (init, step) => {
            this.infinity.bounded(maxInfinity, maxCount).compare((a, b) => a - b).progress(start, forward).perpetual(init, step);
          }
        }),
        perpetual: (init, step) => {
          this.infinity.bounded(maxInfinity, maxCount).compare((a, b) => b - a).progress(0, (x) => x + 1).perpetual(init, step);
        }
      })
    },
    safe: {
      outcome: (pubkey, yes, no, args = {}) => {
        if (this.outcome(pubkey, [`${yes}`], [`${no}`], args)) {
          return yes;
        } else {
          return no;
        }
      },
      if: (pubkey, yes, no, args = {}, allowSwaps = false, allowMisplacedPay = false, strict = true) => {
        const iff = this.if(pubkey, [`${yes}`], [`${no}`], args, allowSwaps, allowMisplacedPay, strict);
        return {
          then: (handler) => {
            const thenn = iff.then((h) => handler(yes, h));
            return {
              else: (handler2) => {
                return thenn.else((h) => handler2(no, h));
              }
            };
          }
        };
      }
    },
    outcome: (pubkey, from, to, step = 1, args = {}, allowMisplacedPay = false, allowFork = false) => ({
      evaluate: (handler) => {
        if (allowFork) {
          this.ignoreObserveChecks = true;
        }
        let numbers = [];
        for (let i = from; i <= to; i += step) {
          numbers.push(i);
        }
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          if (this.outcome(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, false)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.outcome(pubkey, l.map((x) => x.toString()), ["$$$$false"])) {
                  handler(l[0]);
                }
              } else {
                handler(l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              if (this.unsafe.outcome(pubkey, r.map((x) => x.toString()), [])) {
                handler(r[0]);
              }
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        const saveAlicePayCounter = this.alicePayCounter;
        const saveBobPayCounter = this.bobPayCounter;
        recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2));
        const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args);
        this.aliceTrackers[id] += this.alicePayCounter - saveAlicePayCounter > 0 ? 1 : 0;
        this.bobTrackers[id] += this.bobPayCounter - saveBobPayCounter > 0 ? 1 : 0;
        if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.OnePayPerCondition("Only one leaf in a tree is alowed to pay", void 0, void 0, this.selected, this.state);
        }
        if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.PerfectHedgeError("Only one pair in a tree is alowed to pay", this.state, void 0, void 0, this.selected);
        }
      },
      evaluateWithPaymentCtx: (payhandler) => {
        let numbers = [];
        for (let i = from; i <= to; i += step) {
          numbers.push(i);
        }
        const recurse = (l, r, payhandlerOut) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          this.unsafe.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.unsafe.if(pubkey, l.map((x) => x.toString()), ["$$$$false"], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2), h);
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, l[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2), h);
            }
          });
        };
        recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2), null);
      },
      value: () => {
        let numbers = [];
        for (let i = from; i <= to; i += step) {
          numbers.push(i);
        }
        const recurse = (l, r) => {
          if (l.length === 1 && r.length === 0) {
            return l[0];
          }
          if (r.length === 1 && l.length === 0) {
            return r[0];
          }
          if (this.unsafe.outcome(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.unsafe.outcome(pubkey, l.map((x) => x.toString()), ["$$$$false"], args)) {
                  return l[0];
                } else {
                  throw "skip";
                }
              } else {
                return l[0];
              }
            } else {
              return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              return r[0];
            } else {
              return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        return recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2));
      },
      valueWithPaymentCtxUnsafe: () => {
        let numbers = [];
        for (let i = from; i <= to; i += step) {
          numbers.push(i);
        }
        let nn = numbers[0];
        let hh = void 0;
        let payhandler = (h, n) => {
          nn = n;
          hh = h;
        };
        let argument = args;
        const recurse = (l, r, payhandlerOut) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          this.unsafe.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), argument, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.unsafe.if(pubkey, l.map((x) => x.toString()), [], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2), h);
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2), h);
            }
          });
        };
        recurse(numbers.slice(0, numbers.length / 2), numbers.slice(numbers.length / 2), null);
        this.unfinalized++;
        if (hh === void 0) {
          this.unfinalized--;
          throw "skip";
        }
        return [nn, hh];
      }
    })
  };
  set = {
    safe: {
      outcome: (pubkey, yes, no, args = {}, allowMisplacedPay = false) => {
        if (this.outcome(pubkey, [yes], [no], args)) {
          return yes;
        } else {
          return no;
        }
      },
      outcomeT: (pubkey, yes, no, renderer = (x) => x.toString(), args = {}) => {
        if (this.outcome(pubkey, [renderer(yes)], [renderer(no)], args)) {
          return yes;
        } else {
          return no;
        }
      },
      if: (pubkey, yes, no, args = {}) => {
        const iff = this.if(pubkey, [yes], [no], args);
        return {
          then: (handler) => {
            const thenn = iff.then((h) => handler(yes, h));
            return {
              else: (handler2) => {
                return thenn.else((h) => handler2(no, h));
              }
            };
          }
        };
      },
      ifT: (pubkey, yes, no, renderer = (x) => x.toString(), args = {}) => {
        const iff = this.if(pubkey, [renderer(yes)], [renderer(no)], args);
        return {
          then: (handler) => {
            const thenn = iff.then((h) => handler(yes, h));
            return {
              else: (handler2) => {
                return thenn.else((h) => handler2(no, h));
              }
            };
          }
        };
      }
    },
    outcome: (pubkey, set, args = {}, allowMisplacedPay = false, allowFork = true) => ({
      evaluate: (handler) => {
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          if (this.unsafe.outcome(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.unsafe.outcome(pubkey, l, ["$$$$false"])) {
                  handler(l[0]);
                }
              } else {
                handler(l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              handler(r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        const saveAlicePayCounter = this.alicePayCounter;
        const saveBobPayCounter = this.bobPayCounter;
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
        const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args);
        this.aliceTrackers[id] += this.alicePayCounter - saveAlicePayCounter > 0 ? 1 : 0;
        this.bobTrackers[id] += this.bobPayCounter - saveBobPayCounter > 0 ? 1 : 0;
        if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.OnePayPerCondition("Only one leaf in a tree is alowed to pay", void 0, void 0, this.selected, this.state);
        }
        if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.PerfectHedgeError("Only one pair in a tree is alowed to pay", this.state, void 0, void 0, this.selected);
        }
      },
      evaluateWithPaymentCtx: (payhandler) => {
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          this.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.if(pubkey, l.map((x) => x.toString()), ["$$$$false"], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          });
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
      },
      value: () => {
        const recurse = (l, r) => {
          if (l.length === 1 && r.length === 0) {
            return l[0];
          }
          if (r.length === 1 && l.length === 0) {
            return r[0];
          }
          if (this.outcome(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.outcome(pubkey, l.map((x) => x.toString()), ["$$$$false"], args)) {
                  return l[0];
                }
              } else {
                return l[0];
              }
            } else {
              return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              return r[0];
            } else {
              return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        return recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
      },
      valueWithPaymentCtxUnsafe: () => {
        let nn = set[0];
        let hh = void 0;
        const payhandler = (h, n) => {
          nn = n;
          hh = h;
        };
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          this.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.if(pubkey, l.map((x) => x.toString()), ["$$$$false"], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          });
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
        this.unfinalized++;
        if (hh === void 0) {
          this.unfinalized--;
          throw "skip";
        }
        return [nn, hh];
      }
    }),
    outcomeT: (pubkey, set, renderer, args = {}, allowMisplacedPay = false, allowFork = false) => ({
      evaluate: (handler) => {
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          if (this.unsafe.outcome(pubkey, l.map((x) => renderer(x)), r.map((x) => renderer(x)), args)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.unsafe.outcome(pubkey, l.map((x) => renderer(x)), ["$$$$false"])) {
                  handler(l[0]);
                }
              } else {
                handler(l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              handler(r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        const saveAlicePayCounter = this.alicePayCounter;
        const saveBobPayCounter = this.bobPayCounter;
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
        const id = this.megaMode ? pubkey : pubkey + JSON.stringify(args);
        this.aliceTrackers[id] += this.alicePayCounter - saveAlicePayCounter > 0 ? 1 : 0;
        this.bobTrackers[id] += this.bobPayCounter - saveBobPayCounter > 0 ? 1 : 0;
        if (this.strictlyOneLeafPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.OnePayPerCondition("Only one leaf in a tree is alowed to pay", void 0, void 0, this.selected, this.state);
        }
        if (this.strictlyOneLeafPairPays && (this.aliceTrackers[id] > 1 || this.bobPayCounter[id] > 1)) {
          throw new DslErrors.PerfectHedgeError("Only one pair in a tree is alowed to pay", this.state, void 0, void 0, this.selected);
        }
      },
      evaluateWithPaymentCtx: (payhandler) => {
        const recurse = (l, r) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          this.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.if(pubkey, l.map((x) => x.toString()), ["$$$$false"], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          });
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
      },
      value: () => {
        const recurse = (l, r) => {
          if (l.length === 1 && r.length === 0) {
            return l[0];
          }
          if (r.length === 1 && l.length === 0) {
            return r[0];
          }
          if (this.outcome(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args)) {
            if (l.length === 1) {
              if (allowFork) {
                if (this.outcome(pubkey, l.map((x) => x.toString()), ["$$$$false"], args)) {
                  return l[0];
                }
              } else {
                return l[0];
              }
            } else {
              return recurse(l.slice(0, l.length / 2), l.slice(l.length / 2));
            }
          } else {
            if (r.length === 1) {
              return r[0];
            } else {
              return recurse(r.slice(0, r.length / 2), r.slice(r.length / 2));
            }
          }
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        return recurse(set.slice(0, set.length / 2), set.slice(set.length / 2));
      },
      valueWithPaymentCtxUnsafe: () => {
        let nn = set[0];
        let hh = void 0;
        let payhandler = (h, n) => {
          nn = n;
          hh = h;
        };
        const recurse = (l, r, payhandlerOut) => {
          if (l.length === 0) {
            return;
          }
          if (r.length === 0) {
            return;
          }
          const rt = this.if(pubkey, l.map((x) => x.toString()), r.map((x) => x.toString()), args, false, allowMisplacedPay).then((h) => {
            if (l.length === 1) {
              if (allowFork) {
                this.if(pubkey, l.map((x) => x.toString()), ["$$$$false"], args, false, allowMisplacedPay).then((h2) => {
                  payhandler(h2, l[0]);
                });
              } else {
                payhandler(h, l[0]);
              }
            } else {
              recurse(l.slice(0, l.length / 2), l.slice(l.length / 2), h);
            }
          }).else((h) => {
            if (r.length === 1) {
              payhandler(h, r[0]);
            } else {
              recurse(r.slice(0, r.length / 2), r.slice(r.length / 2), h);
            }
          });
        };
        if (this.strictlyOneLeafPays || this.strictlyOneLeafPairPays) {
          throw Error("Leaf strictness tracking is not available in this mode. Use `evaluate`");
        }
        recurse(set.slice(0, set.length / 2), set.slice(set.length / 2), null);
        this.unfinalized++;
        if (hh === void 0) {
          this.unfinalized--;
          throw "skip";
        }
        return [nn, hh];
      }
    })
  };
  assert = {
    sum: {
      budget: (amount) => {
        if (this.collateral1 + this.collateral2 > amount) {
          throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`);
        }
      },
      parties: (party1, party2) => ({
        budget: (amount) => {
          if (this.isSelected0(party1) && this.isSelected1(party2)) {
            if (this.collateral1 + this.collateral2 > amount) {
              throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`);
            }
          }
          if (this.isSelected0(party2) && this.isSelected1(party1)) {
            if (this.collateral1 + this.collateral2 > amount) {
              throw Error(`Max mutual budget assertion: ${this.collateral1} > ${amount}`);
            }
          }
        }
      })
    },
    budget: (idx, amount) => {
      if (idx == 0) {
        if (this.collateral1 > amount) {
          throw Error(`Max Alice budget assertion: ${this.collateral1} > ${amount}`);
        }
      } else {
        if (this.collateral1 > amount) {
          throw Error(`Max Bob budget assertion: ${this.collateral2} > ${amount}`);
        }
      }
    },
    parties: (party1, party2) => ({
      budget: (idx, amount) => {
        if (this.isSelected0(party1) && this.isSelected1(party2)) {
          if (idx == 0) {
            if (this.collateral1 > amount) {
              throw Error(`Max ${party1} budget assertion (against ${party2}): ${this.collateral1} > ${amount}`);
            }
          } else {
            if (this.collateral1 > amount) {
              throw Error(`Max ${party2} budget assertion (against ${party1}): ${this.collateral2} > ${amount}`);
            }
          }
        }
        if (this.isSelected0(party2) && this.isSelected1(party1)) {
          if (idx == 0) {
            if (this.collateral1 > amount) {
              throw Error(`Max ${party2} budget assertion (against ${party1}): ${this.collateral1} > ${amount}`);
            }
          } else {
            if (this.collateral1 > amount) {
              throw Error(`Max ${party1} budget assertion (against ${party2}): ${this.collateral2} > ${amount}`);
            }
          }
        }
      }
    })
  };
  disablePartyRoleReversal = false;
  if = (pubkey, yes, no, args = {}, allowSwaps = false, allowMisplacedPay = false, strict = true) => {
    let contradiction = false;
    const yesSet = new Set(yes);
    const noSet = new Set(no);
    if (yes.find((x) => noSet.has(x)) || no.find((x) => yesSet.has(x))) {
      contradiction = true;
    }
    const observation = this.outcome(pubkey, yes, no, args, allowSwaps, strict);
    const currentNode = this.cursor;
    const currentPrevNode = this.prev;
    const currentLastOutcome = this.lastOutcome;
    return {
      then: (handler) => {
        let party = void 0;
        let sum = 0;
        const funds = {
          pay: (idx, amount) => {
            if (party === void 0 || idx === party) {
              sum += amount;
              party = idx;
            } else {
              if (party !== void 0 && idx !== party) {
                if (this.disablePartyRoleReversal) {
                  throw new Error("Party role reversal is disabled!");
                }
                sum -= amount;
              } else {
                throw new DslErrors.PerfectHedgeError("Perfect Hedge! Party cannot benefit regardless of outcome!", this.state, amount, idx, this.selected);
              }
            }
          },
          party: (partyName, partyAsset) => ({
            pays: (counterpartyName, counterpartyAsset) => ({
              amount: (amount, asset) => {
                const party2 = partyName + (partyAsset ? "_" + partyAsset : "");
                const counterparty = counterpartyName + (counterpartyAsset ? "_" + counterpartyAsset : "");
                if (currentNode !== this.cursor && !allowMisplacedPay) {
                  throw Error("Possibly trying to pay nondeterministically! You tried to use outer account context to pay: use the closest `if(...).then/else(account => ...)` please! This also happens when you pay after checking unrelated observations: pay before checking next outcome! You can turn this off by using `dsl.unsafe`");
                }
                if (partyAsset !== asset) {
                  throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`);
                }
                if (!this.multiparty.find((x) => x === party2)) {
                  throw Error("party " + party2 + " not registered! Use .multiple to register parties");
                }
                if (!this.multiparty.find((x) => x === counterparty)) {
                  throw Error("counterparty " + counterparty + " not registered! Use .multiple to register parties");
                }
                if (this.isSelected0(party2) && this.isSelected1(counterparty)) {
                  funds.pay(0, amount);
                } else if (this.isSelected0(counterparty) && this.isSelected1(party2)) {
                  funds.pay(1, amount);
                }
                if (sum < 0 && partyAsset !== counterpartyAsset) {
                  throw new Error(`Semantics: ${partyName} cannot pay negative amount of ${partyAsset} units. It is only allowed if assets are of the same type.`);
                }
                if (contradiction && partyAsset === counterpartyAsset) {
                  throw Error("Contradiction! Outcomes are not mutually exclusive! Cannot allow swaps in same currency!");
                }
              }
            })
          }),
          release: () => {
            if (currentNode !== this.cursor && !allowMisplacedPay) {
              throw Error("Trying to release nondeterministically! You tried to release using outer account context: use the closest `if(...).then/else(account => ...)` please! This also happens if you release after checking unrelated observations: release before next `outcome; use `allowMisplacedPay` in `dsl.if` to disable this check`");
            }
            const saveCursor = this.cursor;
            const savePrev = this.prev;
            const saveFlag = this.flag;
            const saveLastOutcome = this.lastOutcome;
            if (allowMisplacedPay) {
              this.cursor = currentNode;
              this.prev = currentPrevNode;
              this.flag = false;
              this.lastOutcome = currentLastOutcome;
            }
            this.unfinalized--;
            funds.party = void 0;
            funds.pay = void 0;
            if (party !== void 0 && sum !== 0) {
              if (sum > 0) {
                this.pay(party, sum);
              } else if (sum < 0) {
                this.pay(party === 0 ? 1 : 0, -sum);
              }
            }
            this.cursor = saveCursor;
            this.prev = savePrev;
            this.flag = saveFlag;
            this.lastOutcome = saveLastOutcome;
          }
        };
        const finalizeUnsafeInternal = () => {
          if (observation) {
            handler(funds);
            const saveCursor = this.cursor;
            const savePrev = this.prev;
            const saveFlag = this.flag;
            const saveLastOutcome = this.lastOutcome;
            if (allowMisplacedPay) {
              this.cursor = currentNode;
              this.prev = currentPrevNode;
              this.flag = false;
              this.lastOutcome = currentLastOutcome;
            }
            if (party !== void 0 && sum !== 0) {
              if (sum > 0) {
                this.pay(party, sum);
              } else if (sum < 0) {
                this.pay(party === 0 ? 1 : 0, -sum);
              }
            }
            this.cursor = saveCursor;
            this.prev = savePrev;
            this.flag = saveFlag;
            this.lastOutcome = saveLastOutcome;
          }
        };
        finalizeUnsafeInternal();
        return {
          else: (handler2) => {
            let counterparty = void 0;
            let sum2 = 0;
            const funds2 = {
              pay: (idx, amount) => {
                if (counterparty === void 0 || idx === counterparty) {
                  if (party !== void 0 && counterparty !== void 0 && party === counterparty) {
                    throw new DslErrors.PerfectHedgeError("Perfect Hedge! Party cannot benefit regardless of outcome!", this.state, amount, idx, this.selected);
                  }
                  counterparty = idx;
                  sum2 += amount;
                } else {
                  if (counterparty !== void 0 && idx !== counterparty) {
                    if (this.disablePartyRoleReversal) {
                      throw new Error("Party role reversal is disabled!");
                    }
                    sum2 -= amount;
                  } else {
                    throw new DslErrors.PerfectHedgeError("Perfect Hedge! Party cannot benefit regardless of outcome!", this.state, amount, idx, this.selected);
                  }
                }
              },
              party: (partyName, partyAsset) => ({
                pays: (counterpartyName, counterpartyAsset) => ({
                  amount: (amount, asset) => {
                    const party2 = partyName + (partyAsset ? "_" + partyAsset : "");
                    const counterparty2 = counterpartyName + (counterpartyAsset ? "_" + counterpartyAsset : "");
                    if (currentNode !== this.cursor && !allowMisplacedPay) {
                      throw Error("Possibly trying to pay nondeterministically! You tried to use outer account context to pay: use the closest `if(...).then/else(account => ...)` please! This also happens when you pay after checking unrelated observations: pay before checking next outcome! You can turn this off by using `dsl.unsafe`");
                    }
                    if (partyAsset !== asset) {
                      throw Error(`Trying to pay ${asset} from collateral denominated in ${partyAsset}`);
                    }
                    if (!this.multiparty.find((x) => x === party2)) {
                      throw Error("party " + party2 + " not registered! Use .multiple to register parties");
                    }
                    if (!this.multiparty.find((x) => x === counterparty2)) {
                      throw Error("counterparty " + counterparty2 + " not registered! Use .multiple to register parties");
                    }
                    if (!this.multiparty.find((x) => x === party2)) {
                      throw Error("party " + party2 + " not registered! Use .multiple to register parties in " + this.multiparty);
                    }
                    if (!this.multiparty.find((x) => x === counterparty2)) {
                      throw Error("counterparty " + counterparty2 + " not registered! Use .multiple to register parties in " + this.multiparty);
                    }
                    if (this.isSelected0(party2) && this.isSelected1(counterparty2)) {
                      funds2.pay(0, amount);
                    } else if (this.isSelected0(counterparty2) && this.isSelected1(party2)) {
                      funds2.pay(1, amount);
                    }
                  }
                })
              }),
              release: () => {
                if (currentNode !== this.cursor && !allowMisplacedPay) {
                  throw Error("Possibly trying to release nondeterministically! You tried to release using outer account context: use the closest `if(...).then/else(account => ...)` please! This also happens if you release after checking unrelated observations: release before next `outcome`; use `allowMisplacedPay` in `dsl.if` to disable this check");
                }
                const saveCursor = this.cursor;
                const savePrev = this.prev;
                const saveFlag = this.flag;
                const saveLastOutcome = this.lastOutcome;
                if (allowMisplacedPay) {
                  this.cursor = currentNode;
                  this.prev = currentPrevNode;
                  this.flag = false;
                  this.lastOutcome = currentLastOutcome;
                }
                this.unfinalized--;
                funds2.party = void 0;
                funds2.pay = void 0;
                if (counterparty !== void 0 && sum2 !== 0) {
                  if (sum2 > 0) {
                    this.pay(counterparty, sum2);
                  } else if (sum2 < 0) {
                    this.pay(counterparty === 0 ? 1 : 0, -sum2);
                  }
                }
                this.cursor = saveCursor;
                this.prev = savePrev;
                this.flag = saveFlag;
                this.lastOutcome = saveLastOutcome;
              }
            };
            const finalizeUnsafeInternal2 = () => {
              if (!observation) {
                handler2(funds2);
                const saveCursor = this.cursor;
                const savePrev = this.prev;
                const saveFlag = this.flag;
                const saveLastOutcome = this.lastOutcome;
                if (allowMisplacedPay) {
                  this.cursor = currentNode;
                  this.prev = currentPrevNode;
                  this.flag = false;
                  this.lastOutcome = currentLastOutcome;
                }
                if (counterparty !== void 0 && sum2 !== 0) {
                  if (sum2 > 0) {
                    this.pay(counterparty, sum2);
                  } else if (sum2 < 0) {
                    this.pay(counterparty === 0 ? 1 : 0, -sum2);
                  }
                }
                this.cursor = saveCursor;
                this.prev = savePrev;
                this.flag = saveFlag;
                this.lastOutcome = saveLastOutcome;
              }
            };
            finalizeUnsafeInternal2();
          }
        };
      }
    };
  };
  ifAtomicSwapLeg1(lock = "TRUTH", unlockOutcome = "true", allowMisplacedPay = false) {
    return this.if(lock, [unlockOutcome], [unlockOutcome], {}, true, allowMisplacedPay);
  }
  multiflag = false;
  async enumerateWithBoundMulti(collateralBounds) {
    this.multiflag = true;
    const pairs = this.multiparty.map((x) => this.multiparty.map((y) => [x, y]).filter((pair) => pair[0] !== pair[1])).flat().map((x) => x.sort());
    const ids = /* @__PURE__ */ new Set();
    const uniquepairs = pairs.filter((id) => !ids.has(JSON.stringify(id)) && ids.add(JSON.stringify(id)));
    const mutex = new Mutex();
    const res = await Promise.all(uniquepairs.map(async (pair, i) => {
      return await mutex.runExclusive(async () => {
        this.selected = pair;
        if (!collateralBounds[i]) {
          throw Error("Specify bounds for a pair " + pair + " at index: " + i);
        }
        try {
          const subcontract = await this.enumerateWithBound(collateralBounds[i][0], collateralBounds[i][1]);
          return [pair[0], pair[1], subcontract];
        } catch (e) {
          if (e instanceof DslErrors.EmptyDslOutput) {
            return [pair[0], pair[1], void 0];
          } else {
            throw e;
          }
        }
      });
    }));
    this.multiflag = false;
    return res;
  }
  async enumerateWithBound(collateralBound1, collateralBound2) {
    if (this.multiparty.length > 0 && !this.multiflag) {
      throw Error("use `enumerateWithBoundMulti` for multiparty contracts!");
    }
    if (this.protect) {
      throw "Don't call enumerate inside of the body of your script!";
    }
    this.protect = true;
    let next = true;
    const mutex = new Mutex();
    while (next) {
      try {
        this.collateral1 = 0;
        this.collateral2 = 0;
        this.budgetBound1 = collateralBound1;
        this.budgetBound2 = collateralBound2;
        this.memoize = [];
        this.checked = [];
        this.counter = 0;
        this.lastOutcome = void 0;
        this.flag = false;
        await mutex.runExclusive(async () => await this.body(this));
        if (this.unfinalized !== 0) {
          throw new Error("" + this.unfinalized + " resource locks are not released! Every `[v, payments] = valueWithPaymentCtxUnsafe` must have a corresponding `payments.release()`");
        }
        if (this.megaModeStarted && !this.megaMode) {
          throw new Error("All insecure mega mode escape sections must be closed! Forgot `insecure.close.enableMode`?");
        }
        if (this.strictModeStarted && !this.strictlyStrict) {
          throw new Error("All insecure strict mode escape sections must be closed! Forgot `insecure.close.enableMode`?");
        }
        if (this.superModeStarted && !this.superMode) {
          throw new Error("All insecure super mode escape sections must be closed! Forgot `insecure.close.enableMode`?");
        }
        if (this.fairModeStarted && !this.strictlyFair) {
          throw new Error("All insecure fair mode escape sections must be closed! Forgot `insecure.close.enableMode`?");
        }
      } catch (e) {
        if (e === "uninitialized" || e === "skip") {
        } else {
          throw e;
        }
      }
      next = this.next();
    }
    this.protect = false;
    this.leafsFiltered = true;
    let result = this.root;
    while (this.leafsFiltered) {
      this.leafsFiltered = false;
      result = this.filterLeafs(result);
    }
    if (this.strictlyStrict) {
      this.filterLeafs(result, true);
    }
    return result;
  }
};
if (typeof window === "undefined" && __require.main === module) {
  (async () => {
    const model = await new Dsl(async (dsl) => {
      const a = 60;
      if (dsl.outcome("really?", ["YES"], ["NO"])) {
        dsl.pay(Dsl.Bob, a + 100);
        const out1 = dsl.outcome("is it?", ["YES"], ["NO", "DON'T KNOW"]);
        if (out1) {
          dsl.pay(Dsl.Alice, 40);
          if (dsl.outcome("is it?", ["DON'T KNOW"], ["NO", "YES"])) {
            dsl.pay(Dsl.Bob, 40);
            dsl.if("lol?", ["yup"], ["nope"]).then((funds) => {
              funds.pay(Dsl.Bob, 20);
              funds.pay(Dsl.Alice, 30);
            }).else((funds) => {
              funds.pay(Dsl.Bob, 40);
              funds.pay(Dsl.Alice, 10);
            });
          }
        } else {
          dsl.pay(Dsl.Bob, 50);
        }
      } else {
        dsl.pay(Dsl.Alice, 20);
      }
    }).multiple("alice", "bob").enumerateWithBoundMulti([[1e3, 2e4]]);
    console.log(model);
    const multi = await new Dsl(async (dsl) => {
      if (dsl.outcome("really?", ["YES"], ["NO"])) {
        dsl.party("alice").pays("bob").amount(100);
        dsl.party("bob").pays("carol").amount(20);
      } else {
        dsl.party("carol").pays("alice").amount(40);
        dsl.party("bob").pays("alice").amount(40);
        dsl.if("wow?", ["yup"], ["nope"]).then((account) => {
          account.party("alice").pays("carol").amount(30);
          account.party("carol").pays("alice").amount(5);
        }).else((account) => {
          account.party("carol").pays("alice").amount(30);
        });
      }
    }).multiple("alice", "bob", "carol").enumerateWithBoundMulti([[1e3, 2e3], [1e3, 2e3], [1e3, 2e3]]);
    console.log(multi);
    const multi2 = await new Dsl(async (dsl) => {
      const dates = ["today", "tomorrow", "next week", "next month"];
      const capitalisationDates = /* @__PURE__ */ new Set(["next week"]);
      const notional = 1e4;
      const floatingLegIndex = "interest rate index?";
      const fixedRate = 0.8;
      const quantisationStep = 1;
      dates.reduce(([capitalisation1, capitalisation2], date) => {
        const [floatingRate, accounts] = dsl.numeric.outcome(floatingLegIndex, 0, 1, quantisationStep, { date }).valueWithPaymentCtxUnsafe();
        if (capitalisationDates.has(date)) {
          const floatingPayout = (notional + capitalisation1) * (floatingRate / 100);
          const fixedPayout = (notional + capitalisation2) * (fixedRate / 100);
          accounts.party("alice").pays("bob").amount(floatingPayout);
          accounts.party("bob").pays("alice").amount(fixedPayout);
          accounts.release();
          return [0, 0];
        } else {
          accounts.release();
          return [
            notional * (floatingRate / 100) + capitalisation1,
            notional * (fixedRate / 100) + capitalisation2
          ];
        }
      }, [0, 0]);
    }).multiple("alice", "bob").enumerateWithBoundMulti([[5e4, 2e4]]);
    console.log(multi2);
    const assets = await new Dsl(async (dsl) => {
      if (dsl.outcome("really?", ["YES"], ["NO"])) {
        dsl.party("alice", "usd").pays("bob", "btc").amount(1e7, "usd");
      } else {
        dsl.party("bob", "btc").pays("alice", "usd").amount(10, "btc");
      }
    }).multiple(Dsl.account("alice", "usd"), Dsl.account("bob", "btc")).enumerateWithBoundMulti([[1e9, 2e4]]);
    console.log(assets);
    const swap = await new Dsl(async (dsl) => {
      dsl.unsafe.ifAtomicSwapLeg1("lock1", "allowed").then((pay) => {
        dsl.unsafe.ifAtomicSwapLeg1("lock12", "allowed").then((pay2) => {
          pay2.party("bob", "btc").pays("alice", "usd").amount(10, "btc");
        }).else(() => {
        });
        pay.party("alice", "usd").pays("bob", "btc").amount(1e7, "usd");
      }).else((pay) => {
        pay.party("bob", "btc").pays("alice", "usd").amount(10, "btc");
      });
      dsl.numeric.outcome("???", 0, 3).evaluate((x) => {
        dsl.pay(Dsl.Alice, 10);
      });
      dsl.numeric.infinity.bounded(100).perpetual(0, (x, st) => {
        return dsl.infinity.stop;
      });
      dsl.unsafe.numeric.infinity.bounded(100).perpetual({ "alice": 100, "bob": 100 }, (x, st) => {
        const shouldnot = dsl.unsafe.infinity.move([{
          alice: st.alice - 1,
          bob: st.bob - 2
        }, [
          {
            from: ["alice", "usd"],
            to: ["bob", "btc"],
            amount: 1
          },
          {
            from: ["bob", "btc"],
            to: ["alice", "usd"],
            amount: 2
          }
        ]]);
        return dsl.unsafe.infinity.stop([]);
      });
    }).multiple(Dsl.account("alice", "usd"), Dsl.account("bob", "btc")).enumerateWithBoundMulti([[1e10, 2e5]]);
    console.log(swap);
    const turing = (a) => () => {
      if (a > 5) {
        return 7;
      } else {
        return Dsl.recurse.bounded(turing(a)).attempts(30).otherwiseYield(50)();
      }
    };
    console.log(turing(7)());
    console.log(turing(1)());
    console.log("OK!");
  })();
}

// src-web/util/dsl-runtime.ts
var evalDiscreet = async (expression, parties, bounds) => {
  const model = await new Dsl(async (dsl) => {
    const prototypeWhitelist = Sandbox.SAFE_PROTOTYPES;
    const globals = { ...Sandbox.SAFE_GLOBALS, alert };
    prototypeWhitelist.set(Dsl, /* @__PURE__ */ new Set());
    const sandbox = new Sandbox({ globals, prototypeWhitelist });
    const exec = sandbox.compile(expression);
    exec({ dsl, Dsl }).run();
  }).multiple(...parties).enumerateWithBoundMulti(bounds);
  return model;
};
window.evalDiscreet = evalDiscreet;
export {
  evalDiscreet
};
//# sourceMappingURL=discreet-eval.min.js.map
